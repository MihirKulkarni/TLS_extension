This is gnutls.info, produced by makeinfo version 4.13 from gnutls.texi.

This manual is last updated 25 November 2011 for version 3.0.9 of
GnuTLS.

Copyright (C) 2001-2011 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

INFO-DIR-SECTION Software libraries
START-INFO-DIR-ENTRY
* GnuTLS: (gnutls).		GNU Transport Layer Security Library.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION System Administration
START-INFO-DIR-ENTRY
* certtool: (gnutls)Invoking certtool.	Manipulate certificates and keys.
* gnutls-serv: (gnutls)Invoking gnutls-serv.	GnuTLS test server.
* gnutls-cli: (gnutls)Invoking gnutls-cli.	GnuTLS test client.
* gnutls-cli-debug: (gnutls)Invoking gnutls-cli-debug.	GnuTLS debug client.
* psktool: (gnutls)Invoking psktool.	Simple TLS-Pre-Shared-Keys manager.
* srptool: (gnutls)Invoking srptool.	Simple SRP password tool.
END-INFO-DIR-ENTRY


File: gnutls.info,  Node: Top,  Next: Preface,  Up: (dir)

GnuTLS
******

This manual is last updated 25 November 2011 for version 3.0.9 of
GnuTLS.

Copyright (C) 2001-2011 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".

* Menu:

* Preface::
* Introduction to GnuTLS::
* Introduction to TLS::
* Certificate authentication::
* Shared-key and anonymous authentication::
* More on certificate authentication::
* How to use GnuTLS in applications::
* GnuTLS application examples::
* Other included programs::
* Internal architecture of GnuTLS::
* Support::
* Error codes::
* API reference::
* Supported ciphersuites in GnuTLS::
* Copying Information::
* Concept Index::
* Function and Data Index::
* Bibliography::


File: gnutls.info,  Node: Preface,  Next: Introduction to GnuTLS,  Prev: Top,  Up: Top

1 Preface
*********

This document demonstrates and explains the GnuTLS library API.  A
brief introduction to the protocols and the technology involved is also
included so that an application programmer can better understand the
GnuTLS purpose and actual offerings.  Even if GnuTLS is a typical
library software, it operates over several security and cryptographic
protocols which require the programmer to make careful and correct
usage of them. Otherwise it is likely to only obtain a false sense of
security.  The term of security is very broad even if restricted to
computer software, and cannot be confined to a single cryptographic
library.  For that reason, do not consider any program secure just
because it uses GnuTLS; there are several ways to compromise a program
or a communication line and GnuTLS only helps with some of them.

Although this document tries to be self contained, basic network
programming and public key infrastructure (PKI) knowledge is assumed in
most of it. A good introduction to networking can be found in
[_STEVENS_], to public key infrastructure in [_GUTPKI_] and to security
engineering in [_ANDERSON_].

Updated versions of the GnuTLS software and this document will be
available from `http://www.gnutls.org/' and
`http://www.gnu.org/software/gnutls/'.


File: gnutls.info,  Node: Introduction to GnuTLS,  Next: Introduction to TLS,  Prev: Preface,  Up: Top

2 Introduction to GnuTLS
************************

* Menu:

* GnuTLS introduction::
* Downloading and installing::
* Document overview::


File: gnutls.info,  Node: GnuTLS introduction,  Next: Downloading and installing,  Up: Introduction to GnuTLS

2.1 Introduction
================

In brief GnuTLS can be described as a library which offers an API to
access secure communication protocols. These protocols provide privacy
over insecure lines, and were designed to prevent eavesdropping,
tampering, or message forgery.

Technically GnuTLS is a portable ANSI C based library which implements
the protocols ranging from SSL 3.0 to TLS 1.2 (see *note Introduction
to TLS::, for a detailed description of the protocols), accompanied
with the required framework for authentication and public key
infrastructure.  Important features of the GnuTLS library include:

   * Support for TLS 1.2, TLS 1.1, TLS 1.0 and SSL 3.0 protocols.

   * Support for Datagram TLS 1.0.

   * Support for handling and verification of X.509 and OpenPGP
     certificates.

   * Support for password authentication using TLS-SRP.

   * Support for keyed authentication using TLS-PSK.

   * Support for PKCS #11 tokens and smart-cards.


The GnuTLS library consists of three independent parts, namely the "TLS
protocol part", the "Certificate part", and the "Cryptographic
back-end" part.  The "TLS protocol part" is the actual protocol
implementation, and is entirely implemented within the GnuTLS library.
The "Certificate part" consists of the certificate parsing, and
verification functions and it uses functionality from the libtasn1(1)
library.  The "Cryptographic back-end" is provided by the nettle(2)
library.

---------- Footnotes ----------

(1) `http://www.gnu.org/software/libtasn1/'

(2) `http://www.lysator.liu.se/~nisse/nettle/'


File: gnutls.info,  Node: Downloading and installing,  Next: Document overview,  Prev: GnuTLS introduction,  Up: Introduction to GnuTLS

2.2 Downloading and installing
==============================

GnuTLS is available for download at:
`http://www.gnutls.org/download.html'

GnuTLS uses a development cycle where even minor version numbers
indicate a stable release and a odd minor version number indicate a
development release.  For example, GnuTLS 1.6.3 denote a stable release
since 6 is even, and GnuTLS 1.7.11 denote a development release since 7
is odd.

GnuTLS depends on Libnettle, and you will need to install it before
installing GnuTLS.  Libnettle is available from
`http://www.lysator.liu.se/~nisse/nettle/'.  Don't forget to verify the
cryptographic signature after downloading source code packages.

The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the `INSTALL' file that is part of the
distribution archive.  Typically you invoke `./configure' and then
`make check install'.  There are a number of compile-time parameters,
as discussed below.

The compression library, libz, as well as p11-kit are a optional
dependencies.  You can get libz from `http://www.zlib.net/' and p11-kit
from `http://p11-glue.freedesktop.org/'.

The X.509 part of GnuTLS needs ASN.1 functionality, from a library
called libtasn1.  A copy of libtasn1 is included in GnuTLS.  If you
want to install it separately (e.g., to make it possibly to use
libtasn1 in other programs), you can get it from
`http://www.gnu.org/software/gnutls/download.html'.

A few `configure' options may be relevant, summarized below.  They
disable or enable particular features, to create a smaller library with
only the required features.

--disable-srp-authentication
--disable-psk-authentication
--disable-anon-authentication
--disable-extra-pki
--disable-openpgp-authentication
--disable-openssl-compatibility
--without-p11-kit

For the complete list, refer to the output from `configure --help'.


File: gnutls.info,  Node: Document overview,  Prev: Downloading and installing,  Up: Introduction to GnuTLS

2.3 Overview
============

In this document we present an overview of the supported security
protocols in *note Introduction to TLS::, and continue by providing
more information on the certificate authentication in *note Certificate
authentication::, and shared-key as well anonymous authentication in
*note Shared-key and anonymous authentication::. We elaborate on
certificate authentication by demonstrating advanced usage of the API
in *note More on certificate authentication::.  The core of the TLS
library is presented in *note How to use GnuTLS in applications:: and
example applications are listed in *note GnuTLS application examples::.
In *note Other included programs:: the usage of few included programs
that may assist debugging is presented. The last chapter is *note
Internal architecture of GnuTLS:: that provides a short introduction to
GnuTLS' internal architecture.


File: gnutls.info,  Node: Introduction to TLS,  Next: Certificate authentication,  Prev: Introduction to GnuTLS,  Up: Top

3 Introduction to TLS and DTLS
******************************

TLS stands for "Transport Layer Security" and is the successor of SSL,
the Secure Sockets Layer protocol [_SSL3_] designed by Netscape.  TLS
is an Internet protocol, defined by IETF(1), described in [_RFC5246_].
The protocol provides confidentiality, and authentication layers over
any reliable transport layer.  The description, above, refers to TLS
1.0 but applies to all other TLS versions as the differences between
the protocols are not major.

The DTLS protocol, or "Datagram TLS" [_RFC4347_] is a protocol with
identical goals as TLS, but can operate under unreliable transport
layers such as UDP. The discussions below apply to this protocol as
well, except when noted otherwise.

* Menu:

* TLS layers::
* The transport layer::
* The TLS record protocol::
* The TLS Alert Protocol::
* The TLS Handshake Protocol::
* TLS Extensions::
* How to use TLS in application protocols::
* On SSL 2 and older protocols::

---------- Footnotes ----------

(1) IETF, or Internet Engineering Task Force, is a large open
international community of network designers, operators, vendors, and
researchers concerned with the evolution of the Internet architecture
and the smooth operation of the Internet.  It is open to any interested
individual.


File: gnutls.info,  Node: TLS layers,  Next: The transport layer,  Up: Introduction to TLS

3.1 TLS layers
==============

TLS is a layered protocol, and consists of the record protocol, the
handshake protocol and the alert protocol. The record protocol is to
serve all other protocols and is above the transport layer.  The record
protocol offers symmetric encryption, data authenticity, and optionally
compression.  The alert protocol offers some signaling to the other
protocols. It can help informing the peer for the cause of failures and
other error conditions.  *Note The Alert Protocol::, for more
information.  The alert protocol is above the record protocol.

The handshake protocol is responsible for the security parameters'
negotiation, the initial key exchange and authentication.  *Note The
Handshake Protocol::, for more information about the handshake
protocol.  The protocol layering in TLS is shown in *note
fig:tls-layers::.

 [image src="gnutls-layers.png" ]

Figure 3.1: The TLS protocol layers.


File: gnutls.info,  Node: The transport layer,  Next: The TLS record protocol,  Prev: TLS layers,  Up: Introduction to TLS

3.2 The transport layer
=======================

TLS is not limited to any transport layer and can be used above any
transport layer, as long as it is a reliable one.  DTLS can be used
over reliable and unreliable transport layers.  GnuTLS supports TCP and
UDP layers transparently using the Berkeley sockets API. However, any
transport layer can be used by providing callbacks for GnuTLS to access
the transport layer (for details see *note Setting up the transport
layer::).


File: gnutls.info,  Node: The TLS record protocol,  Next: The TLS Alert Protocol,  Prev: The transport layer,  Up: Introduction to TLS

3.3 The TLS record protocol
===========================

The record protocol is the secure communications provider. Its purpose
is to encrypt, authenticate and --optionally-- compress packets.  The
record layer functions can be called at any time after the handshake
process is finished, when there is need to receive or send data. In
DTLS however, due to re-transmission timers used in the handshake
out-of-order handshake data might be received for some time (maximum 60
seconds) after the handshake process is finished. For this reason
programs using DTLS should call the receive functions for every packet
received by the peer, even if no data were expected.

The functions to access the record protocol are limited to send and
receive functions, which might, given the importance of this protocol
in TLS, seem awkward.  This is because the record protocol's parameters
are all set by the handshake protocol.  The record protocol initially
starts with NULL parameters, which means no encryption, and no MAC is
used. Encryption and authentication begin just after the handshake
protocol has finished.

   * *note gnutls_record_send::

   * *note gnutls_record_recv::

   * *note gnutls_record_recv_seq::

* Menu:

* Encryption algorithms used in the record layer::
* Compression algorithms used in the record layer::
* Weaknesses and countermeasures::
* On Record Padding::


File: gnutls.info,  Node: Encryption algorithms used in the record layer,  Next: Compression algorithms used in the record layer,  Up: The TLS record protocol

3.3.1 Encryption algorithms used in the record layer
----------------------------------------------------

Confidentiality in the record layer is achieved by using symmetric
block encryption algorithms like `3DES', `AES' or stream algorithms
like `ARCFOUR_128'.   Ciphers are encryption algorithms that use a
single, secret, key to encrypt and decrypt data. Block algorithms in
CBC mode also provide protection against statistical analysis of the
data.  Thus, if you're using the TLS protocol, a random number of
blocks will be appended to data, to prevent eavesdroppers from guessing
the actual data size.

The supported in GnuTLS ciphers and MAC algorithms are shown in *note
tab:ciphers:: and *note tab:macs::.

Algorithm      Description
------------------------------------------------------------------ 
3DES_CBC        This is the DES block cipher algorithm used with
               triple encryption (EDE). Has 64 bits block size
               and is used in CBC mode.
ARCFOUR_128     ARCFOUR_128 is a compatible algorithm with RSA's
               RC4 algorithm, which is considered to be a trade
               secret. It is a fast cipher but considered weak
               today.
ARCFOUR_40      This is the ARCFOUR cipher fed with a 40 bit key,
               which is considered weak.
AES_CBC         AES or RIJNDAEL is the block cipher algorithm
               that replaces the old DES algorithm.  Has 128
               bits block size and is used in CBC mode.
AES_GCM         This is the AES algorithm in the authenticated
               encryption GCM mode.  This mode combines message
               authentication and encryption and can be
               extremely fast on CPUs that support hardware
               acceleration.
CAMELLIA_CBC    This is an 128-bit block cipher developed by
               Mitsubishi and NTT. It is one of the approved
               ciphers of the European NESSIE and Japanese
               CRYPTREC projects.

Table 3.1: Supported ciphers.

Algorithm      Description
------------------------------------------------------------------ 
MAC_MD5         This is a cryptographic hash algorithm designed
               by Ron Rivest. Outputs 128 bits of data.
MAC_SHA1        A cryptographic hash algorithm designed by NSA.
               Outputs 160 bits of data.
MAC_SHA256      A cryptographic hash algorithm designed by NSA.
               Outputs 256 bits of data.
MAC_AEAD        This indicates that an authenticated encryption
               algorithm, such as GCM, is in use.

Table 3.2: Supported MAC algorithms.


File: gnutls.info,  Node: Compression algorithms used in the record layer,  Next: Weaknesses and countermeasures,  Prev: Encryption algorithms used in the record layer,  Up: The TLS record protocol

3.3.2 Compression algorithms used in the record layer
-----------------------------------------------------

The TLS record layer also supports compression.  The algorithms
implemented in GnuTLS can be found in the table below.  The included
algorithms perform really good when text, or other compressible data
are to be transferred, but offer nothing on already compressed data,
such as compressed images, zipped archives etc.  These compression
algorithms, may be useful in high bandwidth TLS tunnels, and in cases
where network usage has to be minimized. It should be noted however
that compression increases latency.

The record layer compression in GnuTLS is implemented based on
[_RFC3749_]. The supported algorithms are shown in *note
gnutls_compression_method_t::.

   * GNUTLS_COMP_UNKNOWN Unknown compression method.

   * GNUTLS_COMP_NULL The NULL compression method (no compression).

   * GNUTLS_COMP_DEFLATE The DEFLATE compression method from zlib.

   * GNUTLS_COMP_ZLIB Same as `GNUTLS_COMP_DEFLATE'.

Table 3.3


File: gnutls.info,  Node: Weaknesses and countermeasures,  Next: On Record Padding,  Prev: Compression algorithms used in the record layer,  Up: The TLS record protocol

3.3.3 Weaknesses and countermeasures
------------------------------------

Some weaknesses that may affect the security of the record layer have
been found in TLS 1.0 protocol. These weaknesses can be exploited by
active attackers, and exploit the facts that

  1. TLS has separate alerts for "decryption_failed" and
     "bad_record_mac"

  2. The decryption failure reason can be detected by timing the
     response time.

  3. The IV for CBC encrypted packets is the last block of the previous
     encrypted packet.


Those weaknesses were solved in TLS 1.1 [_RFC4346_] which is
implemented in GnuTLS. For this reason we suggest to always negotiate
the highest supported TLS version with the peer.  For a detailed
discussion of the issues see the archives of the TLS Working Group
mailing list and [_CBCATT_].


File: gnutls.info,  Node: On Record Padding,  Prev: Weaknesses and countermeasures,  Up: The TLS record protocol

3.3.4 On record padding
-----------------------

The TLS protocol allows for random padding of records in CBC ciphers,
to prevent statistical analysis based on the length of exchanged
messages (see [_RFC5246_] section 6.2.3.2).  GnuTLS appears to be one
of few implementation that take advantage of this text, and pad records
by a random length.

The TLS implementation in the Symbian operating system, frequently used
by Nokia and Sony-Ericsson mobile phones, cannot handle non-minimal
record padding.  What happens when one of these clients handshake with
a GnuTLS server is that the client will fail to compute the correct MAC
for the record.  The client sends a TLS alert (`bad_record_mac') and
disconnects.  Typically this will result in error messages such as 'A
TLS fatal alert has been received', 'Bad record MAC', or both, on the
GnuTLS server side.

GnuTLS implements a work around for this problem.  However, it has to
be enabled specifically.  It can be enabled by using *note
gnutls_record_disable_padding::, or *note gnutls_priority_set:: with
the `%COMPAT' priority string (see *note Priority Strings::).

If you implement an application that have a configuration file, we
recommend that you make it possible for users or administrators to
specify a GnuTLS protocol priority string, which is used by your
application via *note gnutls_priority_set::.  To allow the best
flexibility, make it possible to have a different priority string for
different incoming IP addresses.


File: gnutls.info,  Node: The TLS Alert Protocol,  Next: The TLS Handshake Protocol,  Prev: The TLS record protocol,  Up: Introduction to TLS

3.4 The TLS alert protocol
==========================

The alert protocol is there to allow signals to be sent between peers.
These signals are mostly used to inform the peer about the cause of a
protocol failure. Some of these signals are used internally by the
protocol and the application protocol does not have to cope with them
(e.g. `GNUTLS_A_CLOSE_NOTIFY'), and others refer to the application
protocol solely (e.g. `GNUTLS_A_USER_CANCELLED').  An alert signal
includes a level indication which may be either fatal or warning. Fatal
alerts always terminate the current connection, and prevent future
re-negotiations using the current session ID. All alert messages are
summarized in *note tab:alerts::.

The alert messages are protected by the record protocol, thus the
information that is included does not leak. You must take extreme care
for the alert information not to leak to a possible attacker, via
public log files etc. The available functions to control the alert
protocol are shown below.

   * *note gnutls_alert_get::

   * *note gnutls_alert_send::

   * *note gnutls_error_to_alert::

   * *note gnutls_alert_get_name::

Available alert messages:
GNUTLS_A_CLOSE_NOTIFY                    0       Close notify
GNUTLS_A_UNEXPECTED_MESSAGE              10      Unexpected message
GNUTLS_A_BAD_RECORD_MAC                  20      Bad record MAC
GNUTLS_A_DECRYPTION_FAILED               21      Decryption failed
GNUTLS_A_RECORD_OVERFLOW                 22      Record overflow
GNUTLS_A_DECOMPRESSION_FAILURE           30      Decompression failed
GNUTLS_A_HANDSHAKE_FAILURE               40      Handshake failed
GNUTLS_A_SSL3_NO_CERTIFICATE             41      No certificate (SSL
                                                 3.0)
GNUTLS_A_BAD_CERTIFICATE                 42      Certificate is bad
GNUTLS_A_UNSUPPORTED_CERTIFICATE         43      Certificate is not
                                                 supported
GNUTLS_A_CERTIFICATE_REVOKED             44      Certificate was
                                                 revoked
GNUTLS_A_CERTIFICATE_EXPIRED             45      Certificate is expired
GNUTLS_A_CERTIFICATE_UNKNOWN             46      Unknown certificate
GNUTLS_A_ILLEGAL_PARAMETER               47      Illegal parameter
GNUTLS_A_UNKNOWN_CA                      48      CA is unknown
GNUTLS_A_ACCESS_DENIED                   49      Access was denied
GNUTLS_A_DECODE_ERROR                    50      Decode error
GNUTLS_A_DECRYPT_ERROR                   51      Decrypt error
GNUTLS_A_EXPORT_RESTRICTION              60      Export restriction
GNUTLS_A_PROTOCOL_VERSION                70      Error in protocol
                                                 version
GNUTLS_A_INSUFFICIENT_SECURITY           71      Insufficient security
GNUTLS_A_INTERNAL_ERROR                  80      Internal error
GNUTLS_A_USER_CANCELED                   90      User canceled
GNUTLS_A_NO_RENEGOTIATION                100     No renegotiation is
                                                 allowed
GNUTLS_A_UNSUPPORTED_EXTENSION           110     An unsupported
                                                 extension was sent
GNUTLS_A_CERTIFICATE_UNOBTAINABLE        111     Could not retrieve
                                                 the specified
                                                 certificate
GNUTLS_A_UNRECOGNIZED_NAME               112     The server name sent
                                                 was not recognized
GNUTLS_A_UNKNOWN_PSK_IDENTITY            115     The SRP/PSK username
                                                 is missing or not
                                                 known


File: gnutls.info,  Node: The TLS Handshake Protocol,  Next: TLS Extensions,  Prev: The TLS Alert Protocol,  Up: Introduction to TLS

3.5 The TLS handshake protocol
==============================

The handshake protocol is responsible for the ciphersuite negotiation,
the initial key exchange, and the authentication of the two peers.
This is fully controlled by the application layer, thus your program
has to set up the required parameters. The main handshake function is
*note gnutls_handshake::. In the next paragraphs we elaborate on the
handshake protocol, i.e., the ciphersuite negotiation.

* Menu:

* TLS Cipher Suites::           TLS session parameters.
* Authentication::              TLS authentication.
* Client Authentication::       Requesting a certificate from the client.
* Resuming Sessions::           Reusing previously established keys.


File: gnutls.info,  Node: TLS Cipher Suites,  Next: Authentication,  Up: The TLS Handshake Protocol

3.5.1 TLS ciphersuites
----------------------

The handshake protocol of TLS negotiates cipher suites of a special
form illustrated by the `TLS_DHE_RSA_WITH_3DES_CBC_SHA' cipher suite
name.  A typical cipher suite contains these parameters:

   * The key exchange algorithm.  `DHE_RSA' in the example.

   * The Symmetric encryption algorithm and mode `3DES_CBC' in this
     example.

   * The MAC(1) algorithm used for authentication.  `MAC_SHA' is used
     in the above example.


The cipher suite negotiated in the handshake protocol will affect the
record protocol, by enabling encryption and data authentication.  Note
that you should not over rely on TLS to negotiate the strongest
available cipher suite. Do not enable ciphers and algorithms that you
consider weak.

All the supported ciphersuites are listed in *note ciphersuites::.

---------- Footnotes ----------

(1) MAC stands for Message Authentication Code. It can be described as
a keyed hash algorithm. See RFC2104.


File: gnutls.info,  Node: Authentication,  Next: Client Authentication,  Prev: TLS Cipher Suites,  Up: The TLS Handshake Protocol

3.5.2 Authentication
--------------------

The key exchange algorithms of the TLS protocol offer authentication,
which is a prerequisite for a secure connection.  The available
authentication methods in GnuTLS follow.

   * Certificate authentication: Authenticated key exchange using
     public key infrastructure and certificates (X.509 or OpenPGP).

   * SRP authentication: Authenticated key exchange using a password.

   * PSK authentication: Authenticated key exchange using a pre-shared
     key.

   * Anonymous authentication: Key exchange without peer authentication.


Key exchange   Description
------------------------------------------------------------------ 
RSA             The RSA algorithm is used to encrypt a key and
               send it to the peer.  The certificate must allow
               the key to be used for encryption.
RSA_EXPORT      The RSA algorithm is used to encrypt a key and
               send it to the peer.  In the EXPORT algorithm,
               the server signs temporary RSA parameters of 512
               bits -- which are considered weak -- and sends
               them to the client.
DHE_RSA         The RSA algorithm is used to sign ephemeral
               Diffie-Hellman parameters which are sent to the
               peer. The key in the certificate must allow the
               key to be used for signing. Note that key
               exchange algorithms which use ephemeral
               Diffie-Hellman parameters, offer perfect forward
               secrecy. That means that even if the private key
               used for signing is compromised, it cannot be
               used to reveal past session data.
ECDHE_RSA       The RSA algorithm is used to sign ephemeral
               elliptic curve Diffie-Hellman parameters which
               are sent to the peer. The key in the certificate
               must allow the key to be used for signing. It
               also offers perfect forward secrecy. That means
               that even if the private key used for signing is
               compromised, it cannot be used to reveal past
               session data.
DHE_DSS         The DSA algorithm is used to sign ephemeral
               Diffie-Hellman parameters which are sent to the
               peer. The certificate must contain DSA parameters
               to use this key exchange algorithm. DSA is the
               algorithm of the Digital Signature Standard (DSS).
ECDHE_ECDSA     The Elliptic curve DSA algorithm is used to sign
               ephemeral elliptic curve Diffie-Hellman
               parameters which are sent to the peer. The
               certificate must contain ECDSA parameters to use
               this key exchange algorithm.

Table 3.4: Supported key exchange algorithms.

Each authentication method is associated with a key exchange method,
shown in *note Table 3.4: tab:key-exchange, and a credentials type.
The contents of the credentials is method-dependent, e.g. certificates
for certificate authentication and should be initialized and associated
with a session (see *note gnutls_credentials_set::).  A mapping of the
key exchange methods with the credential types is shown in *note
tab:key-exchange-cred::.

Authentication     Key exchange       Client         Server
method                                credentials    credentials
-------------------------------------------------------------------- 
Certificate        `KX_RSA',          `CRD_CERTIFICATE'`CRD_CERTIFICATE'
                   `KX_DHE_RSA',                     
                   `KX_DHE_DSS',                     
                   `KX_ECDHE_RSA',                   
                   `KX_ECDHE_ECDSA',                 
                   `KX_RSA_EXPORT'                   
Password and       `KX_SRP_RSA',      `CRD_SRP'      `CRD_CERTIFICATE',
certificate        `KX_SRP_DSS'                      `CRD_SRP'
Password           `KX_SRP'           `CRD_SRP'      `CRD_SRP'
Anonymous          `KX_ANON_DH',      `CRD_ANON'     `CRD_ANON'
                   `KX_ANON_ECDH'                    
Pre-shared key     `KX_PSK',          `CRD_PSK'      `CRD_PSK'
                   `KX_DHE_PSK',                     
                   `KX_ECDHE_PSK'                    

Table 3.5: Key exchange algorithms and the corresponding credential
types.


File: gnutls.info,  Node: Client Authentication,  Next: Resuming Sessions,  Prev: Authentication,  Up: The TLS Handshake Protocol

3.5.3 Client authentication
---------------------------

In the case of ciphersuites that use certificate authentication, the
authentication of the client is optional in TLS.  A server may request
a certificate from the client using the *note
gnutls_certificate_server_set_request:: function. We elaborate in *note
Certificate credentials::.


File: gnutls.info,  Node: Resuming Sessions,  Prev: Client Authentication,  Up: The TLS Handshake Protocol

3.5.4 Resuming sessions
-----------------------

The TLS handshake process performs expensive calculations and a busy
server might easily be put under load. To reduce the load, session
resumption may be used. This is a feature of the TLS protocol which
allows a client to connect to a server after a successful handshake,
without the expensive calculations.  This is achieved by re-using the
previously established keys, meaning the server needs to store the
state of established connections (unless session tickets are used -
*note Session tickets::).

Session resumption is an integral part of GnuTLS, and *note Session
resumption:: and *note ex:resume-client:: illustrate typical uses of it.


File: gnutls.info,  Node: TLS Extensions,  Next: How to use TLS in application protocols,  Prev: The TLS Handshake Protocol,  Up: Introduction to TLS

3.6 TLS extensions
==================

A number of extensions to the TLS protocol have been proposed mainly in
[_TLSEXT_]. The extensions supported in GnuTLS are:

   * Maximum fragment length negotiation

   * Server name indication

   * Session tickets

   * Safe Renegotiation

and they will be discussed in the subsections that follow.

* Menu:

* Maximum fragment length negotiation::
* Server name indication::
* Session tickets::
* Safe renegotiation::


File: gnutls.info,  Node: Maximum fragment length negotiation,  Next: Server name indication,  Up: TLS Extensions

3.6.1 Maximum fragment length negotiation
-----------------------------------------

This extension allows a TLS implementation to negotiate a smaller value
for record packet maximum length. This extension may be useful to
clients with constrained capabilities. The functions shown below can be
used to control this extension.

   * *note gnutls_record_get_max_size::

   * *note gnutls_record_set_max_size::


File: gnutls.info,  Node: Server name indication,  Next: Session tickets,  Prev: Maximum fragment length negotiation,  Up: TLS Extensions

3.6.2 Server name indication
----------------------------

A common problem in HTTPS servers is the fact that the TLS protocol is
not aware of the hostname that a client connects to, when the handshake
procedure begins. For that reason the TLS server has no way to know
which certificate to send.

This extension solves that problem within the TLS protocol, and allows
a client to send the HTTP hostname before the handshake begins within
the first handshake packet.  The functions *note
gnutls_server_name_set:: and *note gnutls_server_name_get:: can be used
to enable this extension, or to retrieve the name sent by a client.

   * *note gnutls_server_name_set::

   * *note gnutls_server_name_get::


File: gnutls.info,  Node: Session tickets,  Next: Safe renegotiation,  Prev: Server name indication,  Up: TLS Extensions

3.6.3 Session tickets
---------------------

To resume a TLS session the server normally store session parameters.
This complicates deployment, and could be avoiding by delegating the
storage to the client. Because session parameters are sensitive they
are encrypted and authenticated with a key only known to the server and
then sent to the client. The Session Ticket extension implements this
idea, and it is documented in RFC 5077 [_TLSTKT_].


File: gnutls.info,  Node: Safe renegotiation,  Prev: Session tickets,  Up: TLS Extensions

3.6.4 Safe renegotiation
------------------------

TLS gives the option to two communicating parties to renegotiate and
update their security parameters. One useful example of this feature
was for a client to initially connect using anonymous negotiation to a
server, and the renegotiate using some authenticated ciphersuite. This
occurred to avoid having the client sending its credentials in the
clear.

However this renegotiation, as initially designed would not ensure that
the party one is renegotiating is the same as the one in the initial
negotiation.  For example one server could forward all renegotiation
traffic to an other server who will see this traffic as an initial
negotiation attempt.

This might be seen as a valid design decision, but it seems it was not
widely known or understood, thus today some application protocols the
TLS renegotiation feature in a manner that enables a malicious server
to insert content of his choice in the beginning of a TLS session.

The most prominent vulnerability was with HTTPS. There servers request
a renegotiation to enforce an anonymous user to use a certificate in
order to access certain parts of a web site.  The attack works by
having the attacker simulate a client and connect to a server, with
server-only authentication, and send some data intended to cause harm.
The server will then require renegotiation from him in order to perform
the request.  When the proper client attempts to contact the server,
the attacker hijacks that connection and forwards traffic to the
initial server that requested renegotiation.  The attacker will not be
able to read the data exchanged between the client and the server.
However, the server will (incorrectly) assume that the initial request
sent by the attacker was sent by the now authenticated client.  The
result is a prefix plain-text injection attack.

The above is just one example.  Other vulnerabilities exists that do
not rely on the TLS renegotiation to change the client's authenticated
status (either TLS or application layer).

While fixing these application protocols and implementations would be
one natural reaction, an extension to TLS has been designed that
cryptographically binds together any renegotiated handshakes with the
initial negotiation.  When the extension is used, the attack is
detected and the session can be terminated.  The extension is specified
in [_RFC5746_].

GnuTLS supports the safe renegotiation extension.  The default behavior
is as follows.  Clients will attempt to negotiate the safe
renegotiation extension when talking to servers.  Servers will accept
the extension when presented by clients.  Clients and servers will
permit an initial handshake to complete even when the other side does
not support the safe renegotiation extension.  Clients and servers will
refuse renegotiation attempts when the extension has not been
negotiated.

Note that permitting clients to connect to servers when the safe
renegotiation extension is not enabled, is open up for attacks.
Changing this default behavior would prevent interoperability against
the majority of deployed servers out there.  We will reconsider this
default behavior in the future when more servers have been upgraded.
Note that it is easy to configure clients to always require the safe
renegotiation extension from servers.

To modify the default behavior, we have introduced some new priority
strings (see *note Priority Strings::).  The `%UNSAFE_RENEGOTIATION'
priority string permits (re-)handshakes even when the safe
renegotiation extension was not negotiated. The default behavior is
`%PARTIAL_RENEGOTIATION' that will prevent renegotiation with clients
and servers not supporting the extension. This is secure for servers
but leaves clients vulnerable to some attacks, but this is a trade-off
between security and compatibility with old servers. The
`%SAFE_RENEGOTIATION' priority string makes clients and servers require
the extension for every handshake. The latter is the most secure option
for clients, at the cost of not being able to connect to legacy
servers. Servers will also deny clients that do not support the
extension from connecting.

It is possible to disable use of the extension completely, in both
clients and servers, by using the `%DISABLE_SAFE_RENEGOTIATION'
priority string however we strongly recommend you to only do this for
debugging and test purposes.

The default values if the flags above are not specified are:
`Server:'
     %PARTIAL_RENEGOTIATION

`Client:'
     %PARTIAL_RENEGOTIATION


For applications we have introduced a new API related to safe
renegotiation.  The *note gnutls_safe_renegotiation_status:: function is
used to check if the extension has been negotiated on a session, and
can be used both by clients and servers.


File: gnutls.info,  Node: How to use TLS in application protocols,  Next: On SSL 2 and older protocols,  Prev: TLS Extensions,  Up: Introduction to TLS

3.7 How to use TLS in application protocols
===========================================

This chapter is intended to provide some hints on how to use the TLS
over simple custom made application protocols.  The discussion below
mainly refers to the TCP/IP transport layer but may be extended to
other ones too.

* Menu:

* Separate ports::
* Upward negotiation::


File: gnutls.info,  Node: Separate ports,  Next: Upward negotiation,  Up: How to use TLS in application protocols

3.7.1 Separate ports
--------------------

Traditionally SSL was used in application protocols by assigning a new
port number for the secure services. That way two separate ports were
assigned, one for the non secure sessions, and one for the secured
ones. This has the benefit that if a user requests a secure session
then the client will try to connect to the secure port and fail
otherwise. The only possible attack with this method is a denial of
service one. The most famous example of this method is the famous "HTTP
over TLS" or HTTPS protocol [_RFC2818_].

Despite its wide use, this method is not as good as it seems.  This
approach starts the TLS Handshake procedure just after the client
connects on the --so called-- secure port.  That way the TLS protocol
does not know anything about the client, and popular methods like the
host advertising in HTTP do not work(1).  There is no way for the
client to say "I connected to YYY server" before the Handshake starts,
so the server cannot possibly know which certificate to use.

Other than that it requires two separate ports to run a single service,
which is unnecessary complication. Due to the fact that there is a
limitation on the available privileged ports, this approach was soon
obsoleted.

---------- Footnotes ----------

(1) See also the Server Name Indication extension on *note serverind::.


File: gnutls.info,  Node: Upward negotiation,  Prev: Separate ports,  Up: How to use TLS in application protocols

3.7.2 Upward negotiation
------------------------

Other application protocols(1)  use a different approach to enable the
secure layer.  They use something often called as the "TLS upgrade"
method. This method is quite tricky but it is more flexible. The idea
is to extend the application protocol to have a "STARTTLS" request,
whose purpose it to start the TLS protocols just after the client
requests it.  This approach does not require any extra port to be
reserved.  There is even an extension to HTTP protocol to support that
method [_RFC2817_].

The tricky part, in this method, is that the "STARTTLS" request is sent
in the clear, thus is vulnerable to modifications.  A typical attack is
to modify the messages in a way that the client is fooled and thinks
that the server does not have the "STARTTLS" capability.  See a typical
conversation of a hypothetical protocol:

     (client connects to the server)

     CLIENT: HELLO I'M MR. XXX

     SERVER: NICE TO MEET YOU XXX

     CLIENT: PLEASE START TLS

     SERVER: OK

     *** TLS STARTS

     CLIENT: HERE ARE SOME CONFIDENTIAL DATA

And see an example of a conversation where someone is acting in between:

     (client connects to the server)

     CLIENT: HELLO I'M MR. XXX

     SERVER: NICE TO MEET YOU XXX

     CLIENT: PLEASE START TLS

     (here someone inserts this message)

     SERVER: SORRY I DON'T HAVE THIS CAPABILITY

     CLIENT: HERE ARE SOME CONFIDENTIAL DATA

As you can see above the client was fooled, and was dummy enough to
send the confidential data in the clear.

How to avoid the above attack? As you may have already noticed this one
is easy to avoid. The client has to ask the user before it connects
whether the user requests TLS or not. If the user answered that he
certainly wants the secure layer the last conversation should be:

     (client connects to the server)

     CLIENT: HELLO I'M MR. XXX

     SERVER: NICE TO MEET YOU XXX

     CLIENT: PLEASE START TLS

     (here someone inserts this message)

     SERVER: SORRY I DON'T HAVE THIS CAPABILITY

     CLIENT: BYE

     (the client notifies the user that the secure connection was not
     possible)

This method, if implemented properly, is far better than the
traditional method, and the security properties remain the same, since
only denial of service is possible. The benefit is that the server may
request additional data before the TLS Handshake protocol starts, in
order to send the correct certificate, use the correct password file,
or anything else!

---------- Footnotes ----------

(1) See LDAP, IMAP etc.


File: gnutls.info,  Node: On SSL 2 and older protocols,  Prev: How to use TLS in application protocols,  Up: Introduction to TLS

3.8 On SSL 2 and older protocols
================================

One of the initial decisions in the GnuTLS development was to implement
the known security protocols for the transport layer.  Initially TLS
1.0 was implemented since it was the latest at that time, and was
considered to be the most advanced in security properties.  Later the
SSL 3.0 protocol was implemented since it is still the only protocol
supported by several servers and there are no serious security
vulnerabilities known.

One question that may arise is why we didn't implement SSL 2.0 in the
library.  There are several reasons, most important being that it has
serious security flaws, unacceptable for a modern security library.
Other than that, this protocol is barely used by anyone these days
since it has been deprecated since 1996.  The security problems in SSL
2.0 include:

   * Message integrity compromised.  The SSLv2 message authentication
     uses the MD5 function, and is insecure.

   * Man-in-the-middle attack.  There is no protection of the handshake
     in SSLv2, which permits a man-in-the-middle attack.

   * Truncation attack.  SSLv2 relies on TCP FIN to close the session,
     so the attacker can forge a TCP FIN, and the peer cannot tell if
     it was a legitimate end of data or not.

   * Weak message integrity for export ciphers.  The cryptographic keys
     in SSLv2 are used for both message authentication and encryption,
     so if weak encryption schemes are negotiated (say 40-bit keys) the
     message authentication code use the same weak key, which isn't
     necessary.


Other protocols such as Microsoft's PCT 1 and PCT 2 were not
implemented because they were also abandoned and deprecated by SSL 3.0
and later TLS 1.0.


File: gnutls.info,  Node: Certificate authentication,  Next: Shared-key and anonymous authentication,  Prev: Introduction to TLS,  Up: Top

4 Certificate authentication
****************************

* Menu:

* Introduction::
* X.509 certificates::
* OpenPGP certificates::
* Digital signatures::


File: gnutls.info,  Node: Introduction,  Next: X.509 certificates,  Up: Certificate authentication

4.1 Introduction
================

The most known authentication method of TLS are certificates.  The PKIX
[_PKIX_] public key infrastructure is daily used by anyone using a
browser today. GnuTLS supports both X.509 certificates [_PKIX_] and
OpenPGP certificates using a common API.


File: gnutls.info,  Node: X.509 certificates,  Next: OpenPGP certificates,  Prev: Introduction,  Up: Certificate authentication

4.2 X.509 certificates
======================

The X.509 protocols rely on a hierarchical trust model. In this trust
model Certification Authorities (CAs) are used to certify entities.
Usually more than one certification authorities exist, and
certification authorities may certify other authorities to issue
certificates as well, following a hierarchical model.

 [image src="gnutls-x509.png" ]

Figure 4.1: An example of the X.509 hierarchical trust model.

One needs to trust one or more CAs for his secure communications. In
that case only the certificates issued by the trusted authorities are
acceptable.  The framework is illustrated on *note Figure 4.1: fig:x509.

* Menu:

* X.509 certificate structure::
* Verifying X.509 certificate paths::
* Verifying a certificate in the context of TLS session::


File: gnutls.info,  Node: X.509 certificate structure,  Next: Verifying X.509 certificate paths,  Up: X.509 certificates

4.2.1 X.509 certificate structure
---------------------------------

An X.509 certificate usually contains information about the certificate
holder, the signer, a unique serial number, expiration dates and some
other fields [_PKIX_] as shown in *note tab:x509::.

Field          Description
------------------------------------------------------------------ 
version         The field that indicates the version of the
               certificate.
serialNumber    This field holds a unique serial number per
               certificate.
signature       The issuing authority's signature.
issuer          Holds the issuer's distinguished name.
validity        The activation and expiration dates.
subject         The subject's distinguished name of the
               certificate.
extensions      The extensions are fields only present in
               version 3 certificates.

Table 4.1: X.509 certificate fields.

The certificate's _subject or issuer name_ is not just a single string.
It is a Distinguished name and in the ASN.1 notation is a sequence of
several object identifiers with their corresponding values. Some of
available OIDs to be used in an X.509 distinguished name are defined in
`gnutls/x509.h'.

The _Version_ field in a certificate has values either 1 or 3 for
version 3 certificates.  Version 1 certificates do not support the
extensions field so it is not possible to distinguish a CA from a
person, thus their usage should be avoided.

The _validity_ dates are there to indicate the date that the specific
certificate was activated and the date the certificate's key would be
considered invalid.

Certificate _extensions_ are there to include information about the
certificate's subject that did not fit in the typical certificate
fields. Those may be e-mail addresses, flags that indicate whether the
belongs to a CA etc.  All the supported X.509 version 3 extensions are
shown in *note tab:x509-ext::.

Extension              OID            Description
-------------------------------------------------------------------- 
Subject key id         2.5.29.14       An identifier of the key of
                                      the subject.
Authority key id       2.5.29.35       An identifier of the
                                      authority's key used to sign
                                      the certificate.
Subject alternative    2.5.29.17       Alternative names to
name                                  subject's distinguished name.
Key usage              2.5.29.15       Constraints the key's usage
                                      of the certificate.
Extended key usage     2.5.29.37       Constraints the purpose of
                                      the certificate.
Basic constraints      2.5.29.19       Indicates whether this is a
                                      CA certificate or not, and
                                      specify the maximum path
                                      lengths of certificate
                                      chains.
CRL distribution       2.5.29.31       This extension is set by
points                                the CA, in order to inform
                                      about the issued CRLs.
Proxy Certification    1.3.6.1.5.5.7.1.14 Proxy Certificates includes
Information                           this extension that contains
                                      the OID of the proxy policy
                                      language used, and can
                                      specify limits on the maximum
                                      lengths of proxy chains.
                                      Proxy Certificates are
                                      specified in [_RFC3820_].

Table 4.2: X.509 certificate extensions.

In GnuTLS the X.509 certificate structures are handled using the
`gnutls_x509_crt_t' type and the corresponding private keys with the
`gnutls_x509_privkey_t' type.  All the available functions for X.509
certificate handling have their prototypes in `gnutls/x509.h'. An
example program to demonstrate the X.509 parsing capabilities can be
found at *note ex:x509-info::.


File: gnutls.info,  Node: Verifying X.509 certificate paths,  Next: Verifying a certificate in the context of TLS session,  Prev: X.509 certificate structure,  Up: X.509 certificates

4.2.2 Verifying X.509 certificate paths
---------------------------------------

Verifying certificate paths is important in X.509 authentication. For
this purpose the following functions are provided.

   * *note gnutls_x509_trust_list_add_cas::

   * *note gnutls_x509_trust_list_add_named_crt::

   * *note gnutls_x509_trust_list_add_crls::

   * *note gnutls_x509_trust_list_verify_crt::

   * *note gnutls_x509_trust_list_verify_named_crt::

The verification function will verify a given certificate chain against
a list of certificate authorities and certificate revocation lists, and
output a bit-wise OR of elements of the `gnutls_certificate_status_t'
enumeration shown in *note gnutls_certificate_status_t::.

   * GNUTLS_CERT_INVALID The certificate is not signed by one of the
     known authorities or the signature is invalid.

   * GNUTLS_CERT_REVOKED Certificate is revoked by its authority.  In
     X.509 this will be set only if CRLs are checked.

   * GNUTLS_CERT_SIGNER_NOT_FOUND The certificate's issuer is not known.
     This is the case if the issue is not included in the trusted
     certificate list.  not found.

   * GNUTLS_CERT_SIGNER_NOT_CA The certiﬁcate’s signer was not a
     CA. This may happen if this was a version 1 certiﬁcate, which is
     common with some CAs, or a version 3 certiﬁcate without the
     basic constrains extension.

   * GNUTLS_CERT_INSECURE_ALGORITHM The certiﬁcate was signed using
     an in- secure algorithm such as MD2 or MD5. These algorithms have
     been broken and should not be trusted.

   * GNUTLS_CERT_NOT_ACTIVATED The certificate is not yet activated.

   * GNUTLS_CERT_EXPIRED The certificate has expired.

Table 4.3

An example of certificate verification is shown in *note ex:verify2::.
It is also possible to have a set of certificates that are trusted for
a particular server but not to authorize other certificates.  This
purpose is served by the functions *note
gnutls_x509_trust_list_add_named_crt:: and *note
gnutls_x509_trust_list_verify_named_crt::.


File: gnutls.info,  Node: Verifying a certificate in the context of TLS session,  Prev: Verifying X.509 certificate paths,  Up: X.509 certificates

4.2.3 Verifying a certificate in the context of TLS session
-----------------------------------------------------------

When operating in the context of a TLS session, the trusted certificate
authority list has been set via the *note
gnutls_certificate_set_x509_trust_file:: and *note
gnutls_certificate_set_x509_crl_file::, thus it is not required to
setup a trusted list as above.  Convenience functions such as *note
gnutls_certificate_verify_peers2:: are equivalent and will verify the
peer's certificate chain in a TLS session.

There is also the possibility to pass some input to the verification
functions in the form of flags. For *note
gnutls_x509_trust_list_verify_crt:: the flags are passed
straightforward, but *note gnutls_certificate_verify_peers2:: depends
on the flags set by calling *note
gnutls_certificate_set_verify_flags::.  All the available flags are
part of the enumeration `gnutls_certificate_verify_flags' shown in
*note gnutls_certificate_verify_flags::.

   * GNUTLS_VERIFY_DISABLE_CA_SIGN If set a signer does not have to be
     a certificate authority. This flag should normaly be disabled,
     unless you know what this means.

   * GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT Allow trusted CA certiﬁcates
     with version 1. This is safer than
     `GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT', and should be used
     instead. That way only signers in your trusted list will be
     allowed to have certiﬁcates of version 1. This is the default.

   * GNUTLS_VERIFY_DO_NOT_ALLOW_SAME If a certificate is not signed by
     anyone trusted but exists in the trusted CA list do not treat it
     as trusted.

   * GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT Allow CA certificates that
     have version 1 (both root and intermediate). This might be
     dangerous since those haven't the basicConstraints extension. Must
     be used in combination with `GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT'.

   * GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2 Allow certificates to be signed
     using the broken MD2 algorithm.

   * GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5 Allow certificates to be signed
     using the broken MD5 algorithm.

   * GNUTLS_VERIFY_DISABLE_TIME_CHECKS Disable checking of activation
     and expiration validity periods of certificate chains. Don't set
     this unless you understand the security implications.

   * GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS If set a signer in the
     trusted list is never checked for expiration or activation.

   * GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT Do not allow trusted CA
     certificates that have version 1.  This option is to be used to
     deprecate all certificates of version 1.

   * GNUTLS_VERIFY_DISABLE_CRL_CHECKS Disable checking for validity
     using certificate revocation lists.

Table 4.4

Although the verification of a certificate path indicates that the
certificate is signed by trusted authority, does not reveal anything
about the peer's identity. It is required to verify if the
certificate's owner is the one you expect. For more information consult
[_RFC2818_] and section *note ex:verify:: for an example.


File: gnutls.info,  Node: OpenPGP certificates,  Next: Digital signatures,  Prev: X.509 certificates,  Up: Certificate authentication

4.3 OpenPGP certificates
========================

The OpenPGP key authentication relies on a distributed trust model,
called the "web of trust". The "web of trust" uses a decentralized
system of trusted introducers, which are the same as a CA. OpenPGP
allows anyone to sign anyone else's public key. When Alice signs Bob's
key, she is introducing Bob's key to anyone who trusts Alice. If
someone trusts Alice to introduce keys, then Alice is a trusted
introducer in the mind of that observer.  For example in *note
fig:openpgp::, David trusts Alice to be an introducer and Alice signed
Bob's key thus Dave trusts Bob's key to be the real one.

 [image src="gnutls-pgp.png" ]

Figure 4.2: An example of the OpenPGP trust model.

There are some key points that are important in that model. In the
example Alice has to sign Bob's key, only if she is sure that the key
belongs to Bob. Otherwise she may also make Dave falsely believe that
this is Bob's key. Dave has also the responsibility to know who to
trust.  This model is similar to real life relations.

Just see how Charlie behaves in the previous example. Although he has
signed Bob's key - because he knows, somehow, that it belongs to Bob -
he does not trust Bob to be an introducer. Charlie decided to trust
only Kevin, for some reason. A reason could be that Bob is lazy enough,
and signs other people's keys without being sure that they belong to
the actual owner.

4.3.1 OpenPGP certificate structure
-----------------------------------

In GnuTLS the OpenPGP key structures [_RFC2440_] are handled using the
`gnutls_openpgp_crt_t' type and the corresponding private keys with the
`gnutls_openpgp_privkey_t' type. All the prototypes for the key
handling functions can be found at `gnutls/openpgp.h'.

4.3.2 Verifying an OpenPGP certificate
--------------------------------------

The verification functions of OpenPGP keys, included in GnuTLS, are
simple ones, and do not use the features of the "web of trust".  For
that reason, if the verification needs are complex, the assistance of
external tools like GnuPG and GPGME(1) is recommended.

In GnuTLS there is a verification function for OpenPGP certificates,
the *note gnutls_openpgp_crt_verify_ring::.  This checks an OpenPGP key
against a given set of public keys (keyring) and returns the key
status. The key verification status is the same as in X.509
certificates, although the meaning and interpretation are different.
For example an OpenPGP key may be valid, if the self signature is ok,
even if no signers were found.  The meaning of verification status
flags is the same as in the X.509 certificates (see *note Table 4.4:
gnutls_certificate_verify_flags.).

   * *note gnutls_openpgp_crt_verify_ring::

   * *note gnutls_openpgp_crt_verify_self::

4.3.3 Verifying a certificate in the context of a TLS session
-------------------------------------------------------------

Similarly with X.509 certificates, one needs to specify the OpenPGP
keyring file in the credentials structure. The certificates in this
file will be  used by *note gnutls_certificate_verify_peers2:: to
verify the signatures in the certificate sent by the peer.

   * *note gnutls_certificate_set_openpgp_keyring_file::

---------- Footnotes ----------

(1) `http://www.gnupg.org/related_software/gpgme/'


File: gnutls.info,  Node: Digital signatures,  Prev: OpenPGP certificates,  Up: Certificate authentication

4.4 Digital signatures
======================

In this section we will provide some information about digital
signatures, how they work, and give the rationale for disabling some of
the algorithms used.

Digital signatures work by using somebody's secret key to sign some
arbitrary data.  Then anybody else could use the public key of that
person to verify the signature.  Since the data may be arbitrary it is
not suitable input to a cryptographic digital signature algorithm. For
this reason and also for performance cryptographic hash algorithms are
used to preprocess the input to the signature algorithm. This works as
long as it is difficult enough to generate two different messages with
the same hash algorithm output. In that case the same signature could
be used as a proof for both messages. Nobody wants to sign an innocent
message of donating 1 Euro  to Greenpeace and find out that he donated
1.000.000 Euro  to Bad Inc.

For a hash algorithm to be called cryptographic the following three
requirements must hold:

  1. Preimage resistance.  That means the algorithm must be one way and
     given the output of the hash function H(x), it is impossible to
     calculate x.

  2. 2nd preimage resistance.  That means that given a pair x,y with
     y=H(x) it is impossible to calculate an x' such that y=H(x').

  3. Collision resistance.  That means that it is impossible to
     calculate random x and x' such H(x')=H(x).

The last two requirements in the list are the most important in digital
signatures. These protect against somebody who would like to generate
two messages with the same hash output. When an algorithm is considered
broken usually it means that the Collision resistance of the algorithm
is less than brute force. Using the birthday paradox the brute force
attack takes 2^((hash size) / 2) operations. Today colliding
certificates using the MD5 hash algorithm have been generated as shown
in [_WEGER_].

There has been cryptographic results for the SHA-1 hash algorithms as
well, although they are not yet critical.  Before 2004, MD5 had a
presumed collision strength of 2^64, but it has been showed to have a
collision strength well under 2^50.  As of November 2005, it is
believed that SHA-1's collision strength is around 2^63.  We consider
this sufficiently hard so that we still support SHA-1.  We anticipate
that SHA-256/386/512 will be used in publicly-distributed certificates
in the future.  When 2^63 can be considered too weak compared to the
computer power available sometime in the future, SHA-1 will be disabled
as well.  The collision attacks on SHA-1 may also get better, given the
new interest in tools for creating them.

4.4.1 Trading security for interoperability
-------------------------------------------

If you connect to a server and use GnuTLS' functions to verify the
certificate chain, and get a `GNUTLS_CERT_INSECURE_ALGORITHM'
validation error (see *note Verifying X.509 certificate paths::), it
means that somewhere in the certificate chain there is a certificate
signed using `RSA-MD2' or `RSA-MD5'.  These two digital signature
algorithms are considered broken, so GnuTLS fails verifying the
certificate.  In some situations, it may be useful to be able to verify
the certificate chain anyway, assuming an attacker did not utilize the
fact that these signatures algorithms are broken.  This section will
give help on how to achieve that.

It is important to know that you do not have to enable any of the flags
discussed here to be able to use trusted root CA certificates
self-signed using `RSA-MD2' or `RSA-MD5'. The certificates in the
trusted list are considered trusted irrespective of the signature.

If you are using *note gnutls_certificate_verify_peers2:: to verify the
certificate chain, you can call *note
gnutls_certificate_set_verify_flags:: with the flags:
   * `GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2'

   * `GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5'
as in the following example:

       gnutls_certificate_set_verify_flags (x509cred,
                                            GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5);

This will tell the verifier algorithm to enable `RSA-MD5' when
verifying the certificates.

If you are using *note gnutls_x509_crt_verify:: or *note
gnutls_x509_crt_list_verify::, you can pass the
`GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5' parameter directly in the `flags'
parameter.

If you are using these flags, it may also be a good idea to warn the
user when verification failure occur for this reason.  The simplest is
to not use the flags by default, and only fall back to using them after
warning the user.  If you wish to inspect the certificate chain
yourself, you can use *note gnutls_certificate_get_peers:: to extract
the raw server's certificate chain, *note gnutls_x509_crt_list_import::
to parse each of the certificates, and then *note
gnutls_x509_crt_get_signature_algorithm:: to find out the signing
algorithm used for each certificate.  If any of the intermediary
certificates are using `GNUTLS_SIGN_RSA_MD2' or `GNUTLS_SIGN_RSA_MD5',
you could present a warning.


File: gnutls.info,  Node: Shared-key and anonymous authentication,  Next: More on certificate authentication,  Prev: Certificate authentication,  Up: Top

5 Shared-key and anonymous authentication
*****************************************

* Menu:

* SRP authentication::
* PSK authentication::
* Anonymous authentication::


File: gnutls.info,  Node: SRP authentication,  Next: PSK authentication,  Up: Shared-key and anonymous authentication

5.1 SRP authentication
======================

* Menu:

* Authentication using SRP::
* Invoking srptool::


File: gnutls.info,  Node: Authentication using SRP,  Next: Invoking srptool,  Up: SRP authentication

5.1.1 Authentication using SRP
------------------------------

GnuTLS supports authentication via the Secure Remote Password or SRP
protocol (see [_RFC2945,TOMSRP_] for a description).  The SRP key
exchange is an extension to the TLS protocol, and it provides an
authenticated with a password key exchange. The peers can be identified
using a single password, or there can be combinations where the client
is authenticated using SRP and the server using a certificate.

The advantage of SRP authentication, over other proposed secure
password authentication schemes, is that SRP is not susceptible to
off-line dictionary attacks.  Moreover, SRP does not require the server
to hold the user's password.  This kind of protection is similar to the
one used traditionally in the UNIX `/etc/passwd' file, where the
contents of this file did not cause harm to the system security if they
were revealed.  The SRP needs instead of the plain password something
called a verifier, which is calculated using the user's password, and
if stolen cannot be used to impersonate the user.  The Stanford SRP
libraries, include a PAM module that synchronizes the system's users
passwords with the SRP password files. That way SRP authentication
could be used for all users of a system.

The implementation in GnuTLS is based on [_TLSSRP_]. The supported key
exchange methods are shown below.

`SRP:'
     Authentication using the SRP protocol.

`SRP_DSS:'
     Client authentication using the SRP protocol. Server is
     authenticated using a certificate with DSA parameters.

`SRP_RSA:'
     Client authentication using the SRP protocol. Server is
     authenticated using a certificate with RSA parameters.


Helper functions are included in GnuTLS, used to generate and maintain
SRP verifiers and password files.  A program to manipulate the required
parameters for SRP authentication is also included.  See *note
srptool::, for more information.

   * *note gnutls_srp_verifier::

   * *note gnutls_srp_base64_encode::

   * *note gnutls_srp_base64_decode::


File: gnutls.info,  Node: Invoking srptool,  Prev: Authentication using SRP,  Up: SRP authentication

5.1.2 Invoking srptool
----------------------

The `srptool' is a very simple program that emulates the programs in
the _Stanford SRP libraries_(1). It requires two files, one called
`tpasswd' which holds usernames and verifiers, and `tpasswd.conf' which
holds generators and primes.

To create tpasswd.conf which holds the generator and prime values for
the SRP protocol, run:

     $ srptool --create-conf /etc/tpasswd.conf

This command will create /etc/tpasswd and will add user 'test' (you
will also be prompted for a password).  Verifiers are stored in a way
that is compatible with libsrp.

     $ srptool --passwd /etc/tpasswd \
         --passwd-conf /etc/tpasswd.conf -u test

This command will check against a password.  If the password matches
the one in /etc/tpasswd you will get an ok.

     $ srptool --passwd /etc/tpasswd \
         --passwd-conf /etc/tpasswd.conf --verify -u test

---------- Footnotes ----------

(1) See `http://srp.stanford.edu/'.


File: gnutls.info,  Node: PSK authentication,  Next: Anonymous authentication,  Prev: SRP authentication,  Up: Shared-key and anonymous authentication

5.2 PSK authentication
======================

* Menu:

* Authentication using PSK::
* Invoking psktool::


File: gnutls.info,  Node: Authentication using PSK,  Next: Invoking psktool,  Up: PSK authentication

5.2.1 Authentication using PSK
------------------------------

Authentication using Pre-shared keys is a method to authenticate using
usernames and binary keys. This protocol avoids making use of public
key infrastructure and expensive calculations, thus it is suitable for
constraint clients.

The implementation in GnuTLS is based on [_TLSPSK_].  The supported PSK
key exchange methods are:

`PSK:'
     Authentication using the PSK protocol.

`DHE-PSK:'
     Authentication using the PSK protocol and Diffie-Hellman key
     exchange.  This method offers perfect forward secrecy.

`ECDHE-PSK:'
     Authentication using the PSK protocol and Elliptic curve
     Diffie-Hellman key exchange.  This method offers perfect forward
     secrecy.


Helper functions to generate and maintain PSK keys are also included in
GnuTLS.

   * *note gnutls_key_generate::

   * *note gnutls_hex_encode::

   * *note gnutls_hex_decode::


File: gnutls.info,  Node: Invoking psktool,  Prev: Authentication using PSK,  Up: PSK authentication

5.2.2 Invoking psktool
----------------------

This is a program to manage PSK username and keys.  It will generate
random keys for the indicated username, using a simple password file
format.

     PSKtool help
     Usage : psktool [options]
          -u, --username username
                                   specify username.
          -p, --passwd FILE        specify a password file.
          -s, --keysize SIZE       specify the key size in bytes.
          -v, --version            prints the program's version number
          -h, --help               shows this help text

The generation of a PSK password file is illustrated in the example
below.  The password is provided in the prompt.

     $ ./psktool -u psk_identity -p psks.txt
     Generating a random key for user 'psk_identity'
     Key stored to psks.txt
     $ cat psks.txt
     psk_identity:88f3824b3e5659f52d00e959bacab954b6540344
     $


File: gnutls.info,  Node: Anonymous authentication,  Prev: PSK authentication,  Up: Shared-key and anonymous authentication

5.3 Anonymous authentication
============================

The anonymous key exchange offers encryption without any indication of
the peer's identity.  This kind of authentication is vulnerable to a
man in the middle attack, but can be used even if there is no prior
communication or shared trusted parties with the peer. Moreover it is
useful when complete anonymity is required.  Unless in one of the above
cases, do not use anonymous authentication.

The available key exchange algorithms for anonymous authentication are
shown below.

`ANON_DH:'
     This algorithm exchanges Diffie-Hellman parameters.

`ANON_ECDH:'
     This algorithm exchanges elliptic curve Diffie-Hellman parameters.
     It is more efficient than ANON_DH on equivalent security levels.



File: gnutls.info,  Node: More on certificate authentication,  Next: How to use GnuTLS in applications,  Prev: Shared-key and anonymous authentication,  Up: Top

6 More on certificate authentication
************************************

* Menu:

* PKCS 10 certificate requests::
* PKIX certificate revocation lists::
* Managing encrypted keys::
* The certtool application::
* Hardware tokens::
* Abstract key types::


File: gnutls.info,  Node: PKCS 10 certificate requests,  Next: PKIX certificate revocation lists,  Up: More on certificate authentication

6.1 PKCS #10 certificate requests
=================================

A certificate request is a structure, which contain information about
an applicant of a certificate service.  It usually contains a private
key, a distinguished name and secondary data such as a challenge
password. GnuTLS supports the requests defined in PKCS #10 [_RFC2986_].
Other formats of certificate requests are not currently supported.

A certificate request can be generated by associating it with a private
key, setting the subject's information and finally self signing it.
The last step ensures that the requester is in possession of the
private key.

   * *note gnutls_x509_crq_set_version::

   * *note gnutls_x509_crq_set_dn_by_oid::

   * *note gnutls_x509_crq_set_key_usage::

   * *note gnutls_x509_crq_set_key_purpose_oid::

   * *note gnutls_x509_crq_set_basic_constraints::

The *note gnutls_x509_crq_set_key:: and *note gnutls_x509_crq_sign2::
functions associate the request with a private key and sign it. If a
request is to be signed with a key residing in a PKCS #11 token it is
recommended to use the signing functions shown in *note Abstract key
types::.

   * *note gnutls_x509_crq_set_key::

   * *note gnutls_x509_crq_sign2::

The following example is about generating a certificate request, and a
private key. A certificate request can be later be processed by a CA
which should return a signed certificate.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>
#include <gnutls/abstract.h>
#include <time.h>

/* This example will generate a private key and a certificate
 * request.
 */

int
main (void)
{
  gnutls_x509_crq_t crq;
  gnutls_x509_privkey_t key;
  unsigned char buffer[10 * 1024];
  size_t buffer_size = sizeof (buffer);
  unsigned int bits;

  gnutls_global_init ();

  /* Initialize an empty certificate request, and
   * an empty private key.
   */
  gnutls_x509_crq_init (&crq);

  gnutls_x509_privkey_init (&key);

  /* Generate an RSA key of moderate security.
   */
  bits = gnutls_sec_param_to_pk_bits (GNUTLS_PK_RSA, GNUTLS_SEC_PARAM_NORMAL);
  gnutls_x509_privkey_generate (key, GNUTLS_PK_RSA, bits, 0);

  /* Add stuff to the distinguished name
   */
  gnutls_x509_crq_set_dn_by_oid (crq, GNUTLS_OID_X520_COUNTRY_NAME,
                                 0, "GR", 2);

  gnutls_x509_crq_set_dn_by_oid (crq, GNUTLS_OID_X520_COMMON_NAME,
                                 0, "Nikos", strlen ("Nikos"));

  /* Set the request version.
   */
  gnutls_x509_crq_set_version (crq, 1);

  /* Set a challenge password.
   */
  gnutls_x509_crq_set_challenge_password (crq, "something to remember here");

  /* Associate the request with the private key
   */
  gnutls_x509_crq_set_key (crq, key);

  /* Self sign the certificate request.
   */
  gnutls_x509_crq_sign2 (crq, key, GNUTLS_DIG_SHA1, 0);

  /* Export the PEM encoded certificate request, and
   * display it.
   */
  gnutls_x509_crq_export (crq, GNUTLS_X509_FMT_PEM, buffer, &buffer_size);

  printf ("Certificate Request: \n%s", buffer);


  /* Export the PEM encoded private key, and
   * display it.
   */
  buffer_size = sizeof (buffer);
  gnutls_x509_privkey_export (key, GNUTLS_X509_FMT_PEM, buffer, &buffer_size);

  printf ("\n\nPrivate key: \n%s", buffer);

  gnutls_x509_crq_deinit (crq);
  gnutls_x509_privkey_deinit (key);

  return 0;

}


File: gnutls.info,  Node: PKIX certificate revocation lists,  Next: Managing encrypted keys,  Prev: PKCS 10 certificate requests,  Up: More on certificate authentication

6.2 PKIX certificate revocation lists
=====================================

A certificate revocation list (CRL) is a structure issued by an
authority periodically containing a list of revoked certificates serial
numbers.  The CRL structure is signed with the issuing authorities'
keys. A typical CRL contains the fields as shown in *note tab:crl::.
Certificate revocation lists are used to complement the expiration date
of a certificate, in order to account for other reasons of revocation,
such as compromised keys, etc.

A certificate request can be generated by associating it with a private
key, setting the subject's information and finally self signing it.
The last step ensures that the requester is in possession of the
private key. Each CRL is valid for limited amount of time and is
required to provide, except for the current issuing time, also the
issuing time of the next update.

Field          Description
------------------------------------------------------------------ 
version         The field that indicates the version of the CRL
               structure.
signature       A signature by the issuing authority.
issuer          Holds the issuer's distinguished name.
thisUpdate      The issuing time of the revocation list.
nextUpdate      The issuing time of the revocation list that
               will update that one.
revokedCertificates List of revoked certificates serial numbers.
extensions      Optional CRL structure extensions.

Table 6.1: Certificate revocation list fields.

   * *note gnutls_x509_crl_set_version::

   * *note gnutls_x509_crl_set_crt_serial::

   * *note gnutls_x509_crl_set_crt::

   * *note gnutls_x509_crl_set_next_update::

   * *note gnutls_x509_crl_set_this_update::

The *note gnutls_x509_crl_sign2:: and *note
gnutls_x509_crl_privkey_sign:: functions sign the revocation list with
a private key. The latter function can be used to sign with a key
residing in a PKCS #11 token.

   * *note gnutls_x509_crl_sign2::

   * *note gnutls_x509_crl_privkey_sign::

Few extensions on the CRL structure are supported, including the CRL
number extension and the authority key identifier.

   * *note gnutls_x509_crl_set_number::

   * *note gnutls_x509_crl_set_authority_key_id::


File: gnutls.info,  Node: Managing encrypted keys,  Next: The certtool application,  Prev: PKIX certificate revocation lists,  Up: More on certificate authentication

6.3 Managing encrypted keys
===========================

Transferring or storing private keys in plain might not be a good idea.
Any access on the keys becomes a fatal compromise.  Storing the keys in
hardware tokens (see *note Hardware tokens::) could solve the storage
problem but it is not always practical or efficient enough. This
section describes alternative ways that involve encryption of the
private keys to store and transfer.

There are two alternatives to use for key encryption, PKCS #8 and #12
methods of private key encryption. The PKCS #8 method only allows
encryption of the private key, whilst the PKCS #12 method allows in
addition the bundling of other data into the structure. That could be
bundling together the certificate as well as the trusted CA certificate.

PKCS #8 structures
------------------

PKCS #8 keys can be imported and exported as normal private keys using
the functions below. An addition to the normal import functions, are a
password and a flags argument. The flags can be any element of the
`gnutls_pkcs_encrypt_flags_t' enumeration. Note however, that GnuTLS
only supports the PKCS #5 PBES2 encryption scheme. Keys encrypted with
the obsolete PBES1 scheme cannot be decrypted.

   * *note gnutls_x509_privkey_import_pkcs8::

   * *note gnutls_x509_privkey_export_pkcs8::

   * GNUTLS_PKCS_PLAIN Unencrypted private key.

   * GNUTLS_PKCS8_PLAIN Same as `GNUTLS_PKCS_PLAIN'.

   * GNUTLS_PKCS_USE_PKCS12_3DES PKCS-12 3DES.

   * GNUTLS_PKCS8_USE_PKCS12_3DES Same as `GNUTLS_PKCS_USE_PKCS12_3DES'.

   * GNUTLS_PKCS_USE_PKCS12_ARCFOUR PKCS-12 ARCFOUR.

   * GNUTLS_PKCS8_USE_PKCS12_ARCFOUR Same as
     `GNUTLS_PKCS_USE_PKCS12_ARCFOUR'.

   * GNUTLS_PKCS_USE_PKCS12_RC2_40 PKCS-12 RC2-40.

   * GNUTLS_PKCS8_USE_PKCS12_RC2_40 Same as
     `GNUTLS_PKCS_USE_PKCS12_RC2_40'.

   * GNUTLS_PKCS_USE_PBES2_3DES PBES2 3DES.

   * GNUTLS_PKCS_USE_PBES2_AES_128 PBES2 AES-128.

   * GNUTLS_PKCS_USE_PBES2_AES_192 PBES2 AES-192.

   * GNUTLS_PKCS_USE_PBES2_AES_256 PBES2 AES-256.

Table 6.2

PKCS #12 structures
-------------------

A PKCS #12 structure [_PKCS12_] usually contains a user's private keys
and certificates. It is commonly used in browsers to export and import
the user's identities.

In GnuTLS the PKCS #12 structures are handled using the
`gnutls_pkcs12_t' type. This is an abstract type that may hold several
`gnutls_pkcs12_bag_t' types.  The bag types are the holders of the
actual data, which may be certificates, private keys or encrypted data.
A bag of type encrypted should be decrypted in order for its data to be
accessed.

The following functions are available to read a PKCS #12 structure.

   * *note gnutls_pkcs12_get_bag::

   * *note gnutls_pkcs12_verify_mac::

   * *note gnutls_pkcs12_bag_decrypt::

   * *note gnutls_pkcs12_bag_get_count::

   * *note gnutls_pkcs12_bag_get_data::

   * *note gnutls_pkcs12_bag_get_key_id::

   * *note gnutls_pkcs12_bag_get_friendly_name::

The functions below are used to generate a PKCS #12 structure. An
example of their usage is also shown.

   * *note gnutls_pkcs12_set_bag::

   * *note gnutls_pkcs12_bag_encrypt::

   * *note gnutls_pkcs12_generate_mac::

   * *note gnutls_pkcs12_bag_set_data::

   * *note gnutls_pkcs12_bag_set_crl::

   * *note gnutls_pkcs12_bag_set_crt::

   * *note gnutls_pkcs12_bag_set_key_id::

   * *note gnutls_pkcs12_bag_set_friendly_name::

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>
#include <gnutls/pkcs12.h>

#include "examples.h"

#define OUTFILE "out.p12"

/* This function will write a pkcs12 structure into a file.
 * cert: is a DER encoded certificate
 * pkcs8_key: is a PKCS #8 encrypted key (note that this must be
 *  encrypted using a PKCS #12 cipher, or some browsers will crash)
 * password: is the password used to encrypt the PKCS #12 packet.
 */
int
write_pkcs12 (const gnutls_datum_t * cert,
              const gnutls_datum_t * pkcs8_key, const char *password)
{
  gnutls_pkcs12_t pkcs12;
  int ret, bag_index;
  gnutls_pkcs12_bag_t bag, key_bag;
  char pkcs12_struct[10 * 1024];
  size_t pkcs12_struct_size;
  FILE *fd;

  /* A good idea might be to use gnutls_x509_privkey_get_key_id()
   * to obtain a unique ID.
   */
  gnutls_datum_t key_id = { (char *) "\x00\x00\x07", 3 };

  gnutls_global_init ();

  /* Firstly we create two helper bags, which hold the certificate,
   * and the (encrypted) key.
   */

  gnutls_pkcs12_bag_init (&bag);
  gnutls_pkcs12_bag_init (&key_bag);

  ret = gnutls_pkcs12_bag_set_data (bag, GNUTLS_BAG_CERTIFICATE, cert);
  if (ret < 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  /* ret now holds the bag's index.
   */
  bag_index = ret;

  /* Associate a friendly name with the given certificate. Used
   * by browsers.
   */
  gnutls_pkcs12_bag_set_friendly_name (bag, bag_index, "My name");

  /* Associate the certificate with the key using a unique key
   * ID.
   */
  gnutls_pkcs12_bag_set_key_id (bag, bag_index, &key_id);

  /* use weak encryption for the certificate.
   */
  gnutls_pkcs12_bag_encrypt (bag, password, GNUTLS_PKCS_USE_PKCS12_RC2_40);

  /* Now the key.
   */

  ret = gnutls_pkcs12_bag_set_data (key_bag,
                                    GNUTLS_BAG_PKCS8_ENCRYPTED_KEY,
                                    pkcs8_key);
  if (ret < 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  /* Note that since the PKCS #8 key is already encrypted we don't
   * bother encrypting that bag.
   */
  bag_index = ret;

  gnutls_pkcs12_bag_set_friendly_name (key_bag, bag_index, "My name");

  gnutls_pkcs12_bag_set_key_id (key_bag, bag_index, &key_id);


  /* The bags were filled. Now create the PKCS #12 structure.
   */
  gnutls_pkcs12_init (&pkcs12);

  /* Insert the two bags in the PKCS #12 structure.
   */

  gnutls_pkcs12_set_bag (pkcs12, bag);
  gnutls_pkcs12_set_bag (pkcs12, key_bag);


  /* Generate a message authentication code for the PKCS #12
   * structure.
   */
  gnutls_pkcs12_generate_mac (pkcs12, password);

  pkcs12_struct_size = sizeof (pkcs12_struct);
  ret =
    gnutls_pkcs12_export (pkcs12, GNUTLS_X509_FMT_DER, pkcs12_struct,
                          &pkcs12_struct_size);
  if (ret < 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  fd = fopen (OUTFILE, "w");
  if (fd == NULL)
    {
      fprintf (stderr, "cannot open file\n");
      return 1;
    }
  fwrite (pkcs12_struct, 1, pkcs12_struct_size, fd);
  fclose (fd);

  gnutls_pkcs12_bag_deinit (bag);
  gnutls_pkcs12_bag_deinit (key_bag);
  gnutls_pkcs12_deinit (pkcs12);

  return 0;
}


File: gnutls.info,  Node: The certtool application,  Next: Hardware tokens,  Prev: Managing encrypted keys,  Up: More on certificate authentication

6.4 The certtool application
============================

This is a program to generate X.509 certificates, certificate requests,
CRLs and private keys.

     Certtool help
     Usage: certtool [options]
          -s, --generate-self-signed
                                   Generate a self-signed certificate.
          -c, --generate-certificate
                                   Generate a signed certificate.
          --generate-proxy         Generate a proxy certificate.
          --generate-crl           Generate a CRL.
          -u, --update-certificate
                                   Update a signed certificate.
          -p, --generate-privkey   Generate a private key.
          -q, --generate-request   Generate a PKCS #10 certificate
                                   request.
          -e, --verify-chain       Verify a PEM encoded certificate chain.
                                   The last certificate in the chain must
                                   be a self signed one.
          --verify                 Verify a PEM encoded certificate chain.
                                   CA certificates must be loaded with
                                   --load-ca-certificate.
          --verify-crl             Verify a CRL.
          --generate-dh-params     Generate PKCS #3 encoded Diffie-Hellman
                                   parameters.
          --get-dh-params          Get the included PKCS #3 encoded
                                   Diffie-Hellman parameters.
          --load-privkey FILE      Private key file to use.
          --load-pubkey FILE       Public key file to use.
          --load-request FILE      Certificate request file to use.
          --load-certificate FILE
                                   Certificate file to use.
          --load-ca-privkey FILE   Certificate authority's private key
                                   file to use.
          --load-ca-certificate FILE
                                   Certificate authority's certificate
                                   file to use.
          --password PASSWORD      Password to use.
          -i, --certificate-info   Print information on a certificate.
          --certificate-pubkey     Print certificate public key.
          --pgp-certificate-info   Print information on a OpenPGP
                                   certificate.
          --pgp-ring-info          Print information on a keyring
                                   structure.
          -l, --crl-info           Print information on a CRL.
          --crq-info               Print information on a Certificate
                                   Request.
          --no-crq-extensions      Do not use extensions in certificate
                                   requests.
          --p12-info               Print information on a PKCS #12
                                   structure.
          --p7-info                Print information on a PKCS #7
                                   structure.
          --smime-to-p7            Convert S/MIME to PKCS #7 structure.
          -k, --key-info           Print information on a private key.
          --pgp-key-info           Print information on a OpenPGP private
                                   key.
          --pubkey-info            Print information on a public key.
          --fix-key                Regenerate the parameters in a private
                                   key.
          --v1                     Generate an X.509 version 1 certificate
                                   (no extensions).
          --to-p12                 Generate a PKCS #12 structure.
          --to-p8                  Generate a PKCS #8 key structure.
          -8, --pkcs8              Use PKCS #8 format for private keys.
          --dsa                    Use DSA keys.
          --ecc                    Use ECC (ECDSA) keys.
          --hash STR               Hash algorithm to use for signing
                                   (MD5,SHA1,RMD160,SHA256,SHA384,SHA512).
          --export-ciphers         Use weak encryption algorithms.
          --inder                  Use DER format for input certificates
                                   and private keys.
          --inraw                  Use RAW/DER format for input
                                   certificates and private keys.
          --outder                 Use DER format for output certificates
                                   and private keys.
          --outraw                 Use RAW/DER format for output
                                   certificates and private keys.
          --bits BITS              specify the number of bits for key
                                   generation.
          --sec-param PARAM        specify the security level
                                   [low|normal|high|ultra].
          --disable-quick-random   Use /dev/random for key generationg,
                                   thus increasing the quality of
                                   randomness used.
          --outfile FILE           Output file.
          --infile FILE            Input file.
          --template FILE          Template file to use for non
                                   interactive operation.
          --pkcs-cipher CIPHER     Cipher to use for pkcs operations
                                   (3des,3des-pkcs12,aes-128,aes-192,aes-25
                                   6,rc2-40,arcfour).
          -d, --debug LEVEL        specify the debug level. Default is 1.
          -h, --help               shows this help text
          -v, --version            shows the program's version

The program can be used interactively or non interactively by
specifying the `--template' command line option. See below for an
example of a template file.

Diffie-Hellman parameter generation
-----------------------------------

To generate parameters for Diffie-Hellman key exchange, use the command:
     $ certtool --generate-dh-params --outfile dh.pem

Self-signed certificate generation
----------------------------------

To create a self signed certificate, use the command:
     $ certtool --generate-privkey --outfile ca-key.pem
     $ certtool --generate-self-signed --load-privkey ca-key.pem \
        --outfile ca-cert.pem

Note that a self-signed certificate usually belongs to a certificate
authority, that signs other certificates.

Private key generation
----------------------

To create a private key (RSA by default), run:

     $ certtool --generate-privkey --outfile key.pem

To create a DSA or elliptic curves (ECDSA) private key use the above
command combined with `--dsa' or `--ecc' options.

Certificate generation
----------------------

To generate a certificate using the private key, use the command:

     $ certtool --generate-certificate --load-privkey key.pem \
        --outfile cert.pem --load-ca-certificate ca-cert.pem \
        --load-ca-privkey ca-key.pem

Alternatively you may create a certificate request, which is needed
when the certificate will be signed by a third party authority.

     $ certtool --generate-request --load-privkey key.pem \
       --outfile request.pem

If the private key is stored in a smart card you can generate a request
by specifying the private key object URL (see *note The p11tool
application:: on how to obtain the URL).

     $ certtool --generate-request --load-privkey pkcs11:(PRIVKEY URL) \
       --load-pubkey pkcs11:(PUBKEY URL) --outfile request.pem

To generate a certificate using the previous request, use the command:

     $ certtool --generate-certificate --load-request request.pem \
        --outfile cert.pem \
        --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem

Certificate information
-----------------------

To view the certificate information, use:

     $ certtool --certificate-info --infile cert.pem

PKCS #12 structure generation
-----------------------------

To generate a PKCS #12 structure using the previous key and
certificate, use the command:

     $ certtool --load-certificate cert.pem --load-privkey key.pem \
       --to-p12 --outder --outfile key.p12

Some tools (reportedly web browsers) have problems with that file
because it does not contain the CA certificate for the certificate.  To
work around that problem in the tool, you can use the
-load-ca-certificate parameter as follows:

     $ certtool --load-ca-certificate ca.pem \
       --load-certificate cert.pem --load-privkey key.pem \
       --to-p12 --outder --outfile key.p12

Proxy certificate generation
----------------------------

Proxy certificate can be used to delegate your credential to a
temporary, typically short-lived, certificate.  To create one from the
previously created certificate, first create a temporary key and then
generate a proxy certificate for it, using the commands:

     $ certtool --generate-privkey > proxy-key.pem
     $ certtool --generate-proxy --load-ca-privkey key.pem \
       --load-privkey proxy-key.pem --load-certificate cert.pem \
       --outfile proxy-cert.pem

Certificate revocation list generation
--------------------------------------

To create an empty Certificate Revocation List (CRL) do:

     $ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
                --load-ca-certificate x509-ca.pem

To create a CRL that contains some revoked certificates, place the
certificates in a file and use `--load-certificate' as follows:

     $ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
       --load-ca-certificate x509-ca.pem --load-certificate revoked-certs.pem

To verify a Certificate Revocation List (CRL) do:

     $ certtool --verify-crl --load-ca-certificate x509-ca.pem < crl.pem

Certtool's template file format:
--------------------------------

A template file can be used to avoid the interactive questions of
certtool. Initially create a file named 'cert.cfg' that contains the
information about the certificate. The template can be used as below:

     $ certtool --generate-certificate cert.pem --load-privkey key.pem  \
        --template cert.cfg \
        --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem

An example certtool template file:

     # X.509 Certificate options
     #
     # DN options

     # The organization of the subject.
     organization = "Koko inc."

     # The organizational unit of the subject.
     unit = "sleeping dept."

     # The locality of the subject.
     # locality =

     # The state of the certificate owner.
     state = "Attiki"

     # The country of the subject. Two letter code.
     country = GR

     # The common name of the certificate owner.
     cn = "Cindy Lauper"

     # A user id of the certificate owner.
     #uid = "clauper"

     # If the supported DN OIDs are not adequate you can set
     # any OID here.
     # For example set the X.520 Title and the X.520 Pseudonym
     # by using OID and string pairs.
     #dn_oid = "2.5.4.12" "Dr." "2.5.4.65" "jackal"

     # This is deprecated and should not be used in new
     # certificates.
     # pkcs9_email = "none@none.org"

     # The serial number of the certificate
     serial = 007

     # In how many days, counting from today, this certificate will expire.
     expiration_days = 700

     # X.509 v3 extensions

     # A dnsname in case of a WWW server.
     #dns_name = "www.none.org"
     #dns_name = "www.morethanone.org"

     # An IP address in case of a server.
     #ip_address = "192.168.1.1"

     # An email in case of a person
     email = "none@none.org"

     # An URL that has CRLs (certificate revocation lists)
     # available. Needed in CA certificates.
     #crl_dist_points = "http://www.getcrl.crl/getcrl/"

     # Whether this is a CA certificate or not
     #ca

     # Whether this certificate will be used for a TLS client
     #tls_www_client

     # Whether this certificate will be used for a TLS server
     #tls_www_server

     # Whether this certificate will be used to sign data (needed
     # in TLS DHE ciphersuites).
     signing_key

     # Whether this certificate will be used to encrypt data (needed
     # in TLS RSA ciphersuites). Note that it is preferred to use different
     # keys for encryption and signing.
     #encryption_key

     # Whether this key will be used to sign other certificates.
     #cert_signing_key

     # Whether this key will be used to sign CRLs.
     #crl_signing_key

     # Whether this key will be used to sign code.
     #code_signing_key

     # Whether this key will be used to sign OCSP data.
     #ocsp_signing_key

     # Whether this key will be used for time stamping.
     #time_stamping_key

     # Whether this key will be used for IPsec IKE operations.
     #ipsec_ike_key


File: gnutls.info,  Node: Hardware tokens,  Next: Abstract key types,  Prev: The certtool application,  Up: More on certificate authentication

6.5 Security modules
====================

* Menu:

* Introduction on security modules::
* PKCS11 Initialization::
* Reading objects::
* Writing objects::
* Using a PKCS11 token with TLS::
* The p11tool application::


File: gnutls.info,  Node: Introduction on security modules,  Next: PKCS11 Initialization,  Up: Hardware tokens

6.5.1 Introduction
------------------

In this section we present the smart-card and hardware security module
support in GnuTLS using PKCS #11 [_PKCS11_]. Hardware security modules
and smart cards provide a way to store private keys and perform
operations on them without exposing them. This allows decoupling
cryptographic keys from the applications that use them providing an
additional security layer.  Since this can also be achieved in software
components such as in Gnome keyring, we will use the term security
module to describe such an isolation interface.

PKCS #11 is plugin API allowing applications to access cryptographic
operations on a security module, as well as to objects residing on it.
PKCS #11 modules exist for hardware tokens such as smart cards(1), the
trusted platform module (TPM)(2) as well as for software modules like
Gnome Keyring.  The objects residing on a security module may be
certificates, public keys, private keys or secret keys. Of those
certificates and public/private key pairs can be used with GnuTLS. PKCS
#11's main advantage is that it allows operations on private key
objects such as decryption and signing without exposing the key.

Moreover PKCS #11 can be (ab)used to allow all applications in the same
operating system to access shared cryptographic keys and certificates
in a uniform way, as in *note fig:pkcs11-vision::.  That way
applications could load their trusted certificate list, as well as user
certificates from a common PKCS #11 module. Such a provider exists in
the Gnome system, being the Gnome Keyring.

 [image src="pkcs11-vision.png" ]

Figure 6.1: PKCS #11 module usage.

---------- Footnotes ----------

(1) `http://www.opensc-project.org'

(2) `http://trousers.sourceforge.net/'


File: gnutls.info,  Node: PKCS11 Initialization,  Next: Reading objects,  Prev: Introduction on security modules,  Up: Hardware tokens

6.5.2 Initialization
--------------------

To allow all the  GnuTLS applications to access PKCS #11 tokens you can
use a configuration per module, stored in `/etc/pkcs11/modules/'.
These are the configuration files of p11-kit(1).  For example a file
that will load the OpenSC module, could be named
`/etc/pkcs11/modules/opensc' and contain the following:

     module: /usr/lib/opensc-pkcs11.so

If you use this file, then there is no need for other initialization in
GnuTLS, except for the PIN and token functions. Those allow retrieving
a PIN when accessing a protected object, such as a private key, as well
as probe the user to insert the token. All the initialization functions
are below.

   * *note gnutls_pkcs11_init::

   * *note gnutls_pkcs11_set_token_function::

   * *note gnutls_pkcs11_set_pin_function::

   * *note gnutls_pkcs11_add_provider::

Note that due to limitations of PKCS #11 there are issues when multiple
libraries are sharing a module. To avoid this problem GnuTLS uses
p11-kit that provides a middleware to control access to resources over
the multiple users.

---------- Footnotes ----------

(1) `http://p11-glue.freedesktop.org/'


File: gnutls.info,  Node: Reading objects,  Next: Writing objects,  Prev: PKCS11 Initialization,  Up: Hardware tokens

6.5.3 Reading objects
---------------------

All PKCS #11 objects are referenced by GnuTLS functions by URLs as
described in [_PKCS11URI_].  This allows for a consistent naming of
objects across systems and applications in the same system. For example
a public key on a smart card may be referenced as:

     pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315; \
     manufacturer=EnterSafe;object=test1;objecttype=public;\
     id=32f153f3e37990b08624141077ca5dec2d15faed

while the smart card itself can be referenced as:
     pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315;manufacturer=EnterSafe

Objects stored in a PKCS #11 token can be extracted if they are not
marked as sensitive. Usually only private keys are marked as sensitive
and cannot be extracted, while certificates and other data can be
retrieved. The functions that can be used to access objects are shown
below.

   * *note gnutls_pkcs11_obj_import_url::

   * *note gnutls_pkcs11_obj_export_url::

   * *note gnutls_pkcs11_obj_get_info::

   * *note gnutls_x509_crt_import_pkcs11::

   * *note gnutls_x509_crt_import_pkcs11_url::

   * *note gnutls_x509_crt_list_import_pkcs11::

Properties of the physical token can also be accessed and altered with
GnuTLS.  For example data in a token can be erased (initialized), PIN
can be altered, etc.

   * *note gnutls_pkcs11_token_init::

   * *note gnutls_pkcs11_token_get_url::

   * *note gnutls_pkcs11_token_get_info::

   * *note gnutls_pkcs11_token_get_flags::

   * *note gnutls_pkcs11_token_set_pin::

The following examples demonstrate the usage of the API. The first
example will list all available PKCS #11 tokens in a system and the
latter will list all certificates in a token that have a corresponding
private key.

     int i;
     char* url;

     gnutls_global_init();

     for (i=0;;i++)
       {
         ret = gnutls_pkcs11_token_get_url(i, &url);
         if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
           break;

         if (ret < 0)
           exit(1);

         fprintf(stdout, "Token[%d]: URL: %s\n", i, url);
         gnutls_free(url);
       }
     gnutls_global_deinit();

#include <config.h>
#include <gnutls/gnutls.h>
#include <gnutls/pkcs11.h>
#include <stdio.h>
#include <stdlib.h>

#define URL "pkcs11:URL"

int
main (int argc, char** argv)
{
  gnutls_pkcs11_obj_t *obj_list;
  gnutls_x509_crt_t xcrt;
  unsigned int obj_list_size = 0;
  gnutls_datum_t cinfo;
  int i, ret;

  obj_list_size = 0;
  ret = gnutls_pkcs11_obj_list_import_url (NULL, &obj_list_size, URL,
                                       GNUTLS_PKCS11_OBJ_ATTR_CRT_WITH_PRIVKEY,
                                       0);
  if (ret < 0 && ret != GNUTLS_E_SHORT_MEMORY_BUFFER)
    return -1;

/* no error checking from now on */
  obj_list = malloc (sizeof (*obj_list) * obj_list_size);

  gnutls_pkcs11_obj_list_import_url (obj_list, &obj_list_size, URL,
                                     GNUTLS_PKCS11_OBJ_ATTR_CRT_WITH_PRIVKEY,
                                     0);

/* now all certificates are in obj_list */
  for (i = 0; i < obj_list_size; i++)
    {

      gnutls_x509_crt_init (&xcrt);

      gnutls_x509_crt_import_pkcs11 (xcrt, obj_list[i]);

      gnutls_x509_crt_print (xcrt, GNUTLS_CRT_PRINT_FULL, &cinfo);

      fprintf (stdout, "cert[%d]:\n %s\n\n", i, cinfo.data);

      gnutls_free (cinfo.data);
      gnutls_x509_crt_deinit (xcrt);
    }

  return 0;
}


File: gnutls.info,  Node: Writing objects,  Next: Using a PKCS11 token with TLS,  Prev: Reading objects,  Up: Hardware tokens

6.5.4 Writing objects
---------------------

With GnuTLS you can copy existing private keys and certificates to a
token. Note that when copying private keys it is recommended to mark
them as sensitive using the `GNUTLS_PKCS11_OBJ_FLAG_MARK_SENSITIVE' to
prevent its extraction. An object can be marked as private using the
flag `GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE', to require PIN to be
entered before accessing the object (for operations or otherwise).

   * *note gnutls_pkcs11_copy_x509_privkey::

   * *note gnutls_pkcs11_copy_x509_crt::

   * *note gnutls_pkcs11_delete_url::


File: gnutls.info,  Node: Using a PKCS11 token with TLS,  Next: The p11tool application,  Prev: Writing objects,  Up: Hardware tokens

6.5.5 Using a PKCS #11 token with TLS
-------------------------------------

It is possible to use a PKCS #11 token to a TLS session, as shown in
*note ex:pkcs11-client::. In addition the following functions can be
used to load PKCS #11 key and certificates by specifying a PKCS #11 URL
instead of a filename.

   * *note gnutls_certificate_set_x509_trust_file::

   * *note gnutls_certificate_set_x509_key_file::


File: gnutls.info,  Node: The p11tool application,  Prev: Using a PKCS11 token with TLS,  Up: Hardware tokens

6.5.6 The p11tool application
-----------------------------

p11tool is a program that is used to access tokens and security modules
that support the PKCS #11 API. It requires individual PKCS #11 modules
to be loaded either with the `--provider' option, or by setting up the
GnuTLS configuration file for PKCS #11 as in *note Hardware tokens::.

     p11tool help
     Usage: p11tool [options]
     Usage: p11tool --list-tokens
     Usage: p11tool --list-all
     Usage: p11tool --export 'pkcs11:...'

          --export URL             Export an object specified by a pkcs11
                                   URL
          --list-tokens            List all available tokens
          --list-mechanisms URL    List all available mechanisms in token.
          --list-all               List all objects specified by a PKCS#11
                                   URL
          --list-all-certs         List all certificates specified by a
                                   PKCS#11 URL
          --list-certs             List certificates that have a private
                                   key specified by a PKCS#11 URL
          --list-privkeys          List private keys specified by a
                                   PKCS#11 URL
          --list-trusted           List certificates marked as trusted,
                                   specified by a PKCS#11 URL
          --initialize URL         Initializes a PKCS11 token.
          --write URL              Writes loaded certificates, private or
                                   secret keys to a PKCS11 token.
          --delete URL             Deletes objects matching the URL.
          --label label            Sets a label for the write operation.
          --trusted                Marks the certificate to be written as
                                   trusted.
          --private                Marks the object to be written as
                                   private (requires PIN).
          --no-private             Marks the object to be written as not
                                   private.
          --login                  Force login to token
          --detailed-url           Export detailed URLs.
          --no-detailed-url        Export less detailed URLs.
          --secret-key HEX_KEY     Provide a hex encoded secret key.
          --load-privkey FILE      Private key file to use.
          --load-pubkey FILE       Private key file to use.
          --load-certificate FILE
                                   Certificate file to use.
          -8, --pkcs8              Use PKCS #8 format for private keys.
          --inder                  Use DER format for input certificates
                                   and private keys.
          --inraw                  Use RAW/DER format for input
                                   certificates and private keys.
          --provider Library       Specify the pkcs11 provider library
          --outfile FILE           Output file.
          -d, --debug LEVEL        specify the debug level. Default is 1.
          -h, --help               shows this help text

After being provided the available PKCS #11 modules, it can list all
tokens available in your system, the objects on the tokens, and perform
operations on them.

Some examples on how to use p11tool are illustrated in the following
paragraphs.

List all tokens
...............

     $ p11tool --list-tokens

List all objects
................

The following command will list all objects in a token. The `--login'
is required to show objects marked as private.
     $ p11tool --login --list-all

Exporting an object
...................

To retrieve an object stored in the card use the following command.
Note however that objects marked as sensitive (typically PKCS #11
private keys) are not allowed to be extracted from the token.
     $ p11tool --login --export [OBJECT URL]

Copy an object to a token
.........................

To copy an object, such as a certificate or private key to a token use
the following command.
     $ p11tool --login --write [TOKEN URL] \
       --load-certificate cert.pem --label "my_cert"


File: gnutls.info,  Node: Abstract key types,  Prev: Hardware tokens,  Up: More on certificate authentication

6.6 Abstract key types
======================

Since there are many forms of a public or private keys supported by
GnuTLS such as X.509, OpenPGP, or PKCS #11 it is desirable to allow
common operations on them. For these reasons the abstract
`gnutls_privkey_t' and `gnutls_pubkey_t' were introduced in
`gnutls/abstract.h' header. Those types are initialized using a
specific type of key and then can be used to perform operations in an
abstract way. For example in order to sign an X.509 certificate with a
key that resides in a token the following steps must be used.

     #inlude <gnutls/abstract.h>
     #inlude <gnutls/pkcs11.h>

     void sign_cert( gnutls_x509_crt_t to_be_signed)
     {
     gnutls_pkcs11_privkey_t ca_key;
     gnutls_x509_crt_t ca_cert;
     gnutls_privkey_t abs_key;

       /* load the PKCS #11 key and certificates */
       gnutls_pkcs11_privkey_init(&ca_key);
       gnutls_pkcs11_privkey_import_url(ca_key, key_url);

       gnutls_x509_crt_init(&ca_cert);
       gnutls_x509_crt_import_pkcs11_url(&ca_cert, cert_url);

       /* initialize the abstract key */
       gnutls_privkey_init(&abs_key);
       gnutls_privkey_import_pkcs11(abs_key, ca_key);

       /* sign the certificate to be signed */
       gnutls_x509_crt_privkey_sign(to_be_signed, ca_cert, ca_key,
                                    GNUTLS_DIG_SHA256, 0);
     }

* Menu:

* Abstract public keys::
* Abstract private keys::
* Operations::


File: gnutls.info,  Node: Abstract public keys,  Next: Abstract private keys,  Up: Abstract key types

6.6.1 Public keys
-----------------

An abstract `gnutls_pubkey_t' can be initialized using the functions
below. It can be imported through an existing structure like
`gnutls_x509_crt_t', or through an ASN.1 encoding of the X.509
`SubjectPublicKeyInfo' sequence.

   * *note gnutls_pubkey_import_x509::

   * *note gnutls_pubkey_import_openpgp::

   * *note gnutls_pubkey_import_pkcs11::

   * *note gnutls_pubkey_import_pkcs11_url::

   * *note gnutls_pubkey_import_privkey::

Additional functions are available that will return information over a
public key.

   * *note gnutls_pubkey_get_pk_algorithm::

   * *note gnutls_pubkey_get_preferred_hash_algorithm::

   * *note gnutls_pubkey_get_key_id::


File: gnutls.info,  Node: Abstract private keys,  Next: Operations,  Prev: Abstract public keys,  Up: Abstract key types

6.6.2 Private keys
------------------

An abstract `gnutls_privkey_t' can be initialized using the functions
below. It can be imported through an existing structure like
`gnutls_x509_privkey_t', but unlike public keys it cannot be exported.
That is to allow abstraction over PKCS #11 keys that are not
extractable.

   * *note gnutls_privkey_import_x509::

   * *note gnutls_privkey_import_openpgp::

   * *note gnutls_privkey_import_pkcs11::

   * *note gnutls_privkey_import_ext::

   * *note gnutls_privkey_get_pk_algorithm::

   * *note gnutls_privkey_get_type::


File: gnutls.info,  Node: Operations,  Prev: Abstract private keys,  Up: Abstract key types

6.6.3 Operations
----------------

The abstract key types can be used to access signing and signature
verification operations with the underlying keys.

   * *note gnutls_pubkey_verify_data2::

   * *note gnutls_pubkey_verify_hash::

   * *note gnutls_privkey_sign_data::

   * *note gnutls_privkey_sign_hash::

Signing existing structures, such as certificates, CRLs, or certificate
requests, as well as associating public keys with structures is also
possible using the key abstractions.

   * *note gnutls_x509_crq_set_pubkey::

   * *note gnutls_x509_crt_set_pubkey::

   * *note gnutls_x509_crt_privkey_sign::

   * *note gnutls_x509_crl_privkey_sign::

   * *note gnutls_x509_crq_privkey_sign::


File: gnutls.info,  Node: How to use GnuTLS in applications,  Next: GnuTLS application examples,  Prev: More on certificate authentication,  Up: Top

7 How to use GnuTLS in applications
***********************************

* Menu:

* Introduction to the library::
* Preparation::
* Session initialization::
* Associating the credentials::
* Setting up the transport layer::
* TLS handshake::
* Data transfer and termination::
* Priority Strings::
* Advanced and other topics::
* Using the cryptographic library::
* Selecting cryptographic key sizes::


File: gnutls.info,  Node: Introduction to the library,  Next: Preparation,  Up: How to use GnuTLS in applications

7.1 Introduction
================

* Menu:

* General idea::
* Error handling::
* Debugging and auditing::
* Thread safety::
* Callback functions::


File: gnutls.info,  Node: General idea,  Next: Error handling,  Up: Introduction to the library

7.1.1 General idea
------------------

A brief description of how GnuTLS works internally is shown at *note
fig:gnutls-design::. This section may become more clear after having
read the rest of this section.  As shown in the figure, there is a
read-only global state that is initialized once by the global
initialization function.  This global structure, among others, contains
the memory allocation functions used, and structures needed for the
ASN.1 parser.  This structure is never modified by any GnuTLS function,
except for the deinitialization function which frees all allocated
memory and is called after the program has permanently finished using
GnuTLS.

 [image src="gnutls-internals.png" ]

Figure 7.1: High level design of GnuTLS.

The credentials structures are used by the authentication methods, such
as certificate authentication. They store certificates, privates keys,
and other information that is needed to prove the identity to the peer,
and/or verify the indentity of the peer. The information stored in the
credentials structures is initialized once and then can be shared by
many TLS sessions.

A GnuTLS session contains all the required information to handle one
secure connection. The session communicates with the peers using the
provided functions of the transport layer.  Every session has a unique
session ID shared with the peer.

Since TLS sessions can be resumed, servers need a database back-end to
hold the session's parameters.  Every GnuTLS session after a successful
handshake calls the appropriate back-end function (see *note resume::)
to store the newly negotiated session. The session database is examined
by the server just after having received the client hello(1), and if
the session ID sent by the client, matches a stored session, the stored
session will be retrieved, and the new session will be a resumed one,
and will share the same session ID with the previous one.

---------- Footnotes ----------

(1) The first message in a TLS handshake


File: gnutls.info,  Node: Error handling,  Next: Debugging and auditing,  Prev: General idea,  Up: Introduction to the library

7.1.2 Error handling
--------------------

In GnuTLS most functions return an integer type as a result.  In almost
all cases a zero or a positive number means success, and a negative
number indicates failure, or a situation that some action has to be
taken. Thus negative error codes may be fatal or not.

Fatal errors terminate the connection immediately and further sends and
receives will be disallowed.  Such an example is
`GNUTLS_E_DECRYPTION_FAILED'. Non-fatal errors may warn about
something, i.e., a warning alert was received, or indicate the some
action has to be taken. This is the case with the error code
`GNUTLS_E_REHANDSHAKE' returned by *note gnutls_record_recv::.  This
error code indicates that the server requests a re-handshake. The
client may ignore this request, or may reply with an alert.  You can
test if an error code is a fatal one by using the *note
gnutls_error_is_fatal::.

If any non fatal errors, that require an action, are to be returned by
a function, these error codes will be documented in the function's
reference.  See *note Error codes::, for a description of the available
error codes.


File: gnutls.info,  Node: Debugging and auditing,  Next: Thread safety,  Prev: Error handling,  Up: Introduction to the library

7.1.3 Debugging and auditing
----------------------------

In many cases things may not go as expected and further information, to
assist debugging, from GnuTLS is desired.  Those are the cases where
the *note gnutls_global_set_log_level:: and *note
gnutls_global_set_log_function:: are to be used. Those will print
verbose information on the GnuTLS functions internal flow.

   * *note gnutls_global_set_log_level::

   * *note gnutls_global_set_log_function::

When debugging is not required, important issues, such as detected
attacks on the protocol still need to be logged. This is provided by
the logging function set by *note
gnutls_global_set_audit_log_function::. The provided function will
receive an message and the corresponding TLS session. The session
information might be used to derive IP addresses or other information
about the peer involved.

   * *note gnutls_global_set_audit_log_function::


File: gnutls.info,  Node: Thread safety,  Next: Callback functions,  Prev: Debugging and auditing,  Up: Introduction to the library

7.1.4 Thread safety
-------------------

The GnuTLS library is thread safe by design, meaning that objects of
the library such as TLS sessions, can be safely divided across threads
as long as a single thread accesses a single object. This is sufficient
to support a server which handles several sessions per thread.  If,
however, an object needs to be shared across threads then access must be
protected with a mutex. Read-only access to objects, for example the
credentials holding structures (see *note Authentication::), is also
thread-safe.

The random generator of the cryptographic back-end, is not thread safe
and requires mutex locks which are setup by GnuTLS.  Applications can
either call *note gnutls_global_init:: which will initialize the default
operating system provided locks (i.e. `pthreads' on GNU/Linux and
`CriticalSection' on Windows), or specify manually the locking system
using the function *note gnutls_global_set_mutex:: before calling *note
gnutls_global_init::.  Setting manually mutexes is recommended only to
applications that have full control of the underlying libraries. If this
is not the case, the use of the operating system defaults is
recommended. An example of non-native thread usage is shown below.

     #include <gnutls.h>

     /* Other thread packages
      */

     int main()
     {
        gnutls_global_set_mutex (mutex_init, mutex_deinit,
                                 mutex_lock, mutex_unlock);
        gnutls_global_init();
     }

   * *note gnutls_global_set_mutex::


File: gnutls.info,  Node: Callback functions,  Prev: Thread safety,  Up: Introduction to the library

7.1.5 Callback functions
------------------------

There are several cases where GnuTLS may need out of band input from
your program. This is now implemented using some callback functions,
which your program is expected to register.

An example of this type of functions are the push and pull callbacks
which are used to specify the functions that will retrieve and send
data to the transport layer.

   * *note gnutls_transport_set_push_function::

   * *note gnutls_transport_set_pull_function::

Other callback functions may require more complicated input and data to
be allocated. Such an example is *note
gnutls_srp_set_server_credentials_function::.  All callbacks should
allocate and free memory using `gnutls_malloc' and `gnutls_free'.


File: gnutls.info,  Node: Preparation,  Next: Session initialization,  Prev: Introduction to the library,  Up: How to use GnuTLS in applications

7.2 Preparation
===============

To use GnuTLS, you have to perform some changes to your sources and
your build system. The necessary changes are explained in the following
subsections.

* Menu:

* Headers::
* Initialization::
* Version check::
* Building the source::


File: gnutls.info,  Node: Headers,  Next: Initialization,  Up: Preparation

7.2.1 Headers
-------------

All the data types and functions of the GnuTLS library are defined in
the header file `gnutls/gnutls.h'.  This must be included in all
programs that make use of the GnuTLS library.


File: gnutls.info,  Node: Initialization,  Next: Version check,  Prev: Headers,  Up: Preparation

7.2.2 Initialization
--------------------

GnuTLS must be initialized before it can be used.  The library is
initialized by calling *note gnutls_global_init::.  The resources
allocated by the initialization process can be released if the
application no longer has a need to call GnuTLS functions, this is done
by calling *note gnutls_global_deinit::.

In order to take advantage of the internationalization features in
GnuTLS, such as translated error messages, the application must set the
current locale using `setlocale' before initializing GnuTLS.


File: gnutls.info,  Node: Version check,  Next: Building the source,  Prev: Initialization,  Up: Preparation

7.2.3 Version check
-------------------

It is often desirable to check that the version of `gnutls' used is
indeed one which fits all requirements.  Even with binary compatibility
new features may have been introduced but due to problem with the
dynamic linker an old version is actually used.  So you may want to
check that the version is okay right after program start-up.  See the
function *note gnutls_check_version::.


File: gnutls.info,  Node: Building the source,  Prev: Version check,  Up: Preparation

7.2.4 Building the source
-------------------------

If you want to compile a source file including the `gnutls/gnutls.h'
header file, you must make sure that the compiler can find it in the
directory hierarchy.  This is accomplished by adding the path to the
directory in which the header file is located to the compilers include
file search path (via the `-I' option).

However, the path to the include file is determined at the time the
source is configured.  To solve this problem, the library uses the
external package `pkg-config' that knows the path to the include file
and other configuration options.  The options that need to be added to
the compiler invocation at compile time are output by the `--cflags'
option to `pkg-config gnutls'.  The following example shows how it can
be used at the command line:

     gcc -c foo.c `pkg-config gnutls --cflags`

Adding the output of `pkg-config gnutls --cflags' to the compilers
command line will ensure that the compiler can find the
`gnutls/gnutls.h' header file.

A similar problem occurs when linking the program with the library.
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search
path (via the `-L' option).  For this, the option `--libs' to
`pkg-config gnutls' can be used.  For convenience, this option also
outputs all other options that are required to link the program with
the library (for instance, the `-ltasn1' option).  The example shows
how to link `foo.o' with the library to a program `foo'.

     gcc -o foo foo.o `pkg-config gnutls --libs`

Of course you can also combine both examples to a single command by
specifying both options to `pkg-config':

     gcc -o foo foo.c `pkg-config gnutls --cflags --libs`


File: gnutls.info,  Node: Session initialization,  Next: Associating the credentials,  Prev: Preparation,  Up: How to use GnuTLS in applications

7.3 Session initialization
==========================

In the previous sections we have discussed the global initialization
required for GnuTLS as well as the initialization required for each
authentication method's credentials (see *note Authentication::).  In
this section we elaborate on the TLS or DTLS session initiation.  Each
session is initialized using *note gnutls_init:: which among others is
used to specify the type of the connection (server or client), and the
underlying protocol type, i.e., datagram (UDP) or reliable (TCP).

   * *note gnutls_init::

After the session initialization details on the allowed ciphersuites
and protocol versions should be set using the priority functions such
as *note gnutls_priority_set_direct::. We elaborate on them in *note
Priority Strings::.  The credentials used for the key exchange method,
such as certificates or usernames and passwords should also be
associated with the session current session using *note
gnutls_credentials_set::.

   * *note gnutls_credentials_set::


File: gnutls.info,  Node: Associating the credentials,  Next: Setting up the transport layer,  Prev: Session initialization,  Up: How to use GnuTLS in applications

7.4 Associating the credentials
===============================

* Menu:

* Certificate credentials::
* SRP credentials::
* PSK credentials::
* Anonymous credentials::


File: gnutls.info,  Node: Certificate credentials,  Next: SRP credentials,  Up: Associating the credentials

7.4.1 Certificates
------------------

Server certificate authentication
.................................

When using certificates the server is required to have at least one
certificate and private key pair. Clients may not hold such a pair, but
a server could require it. On this section we discuss general issues
applying to both client and server certificates. The next section will
elaborate on issues arising from client authentication only.

   * *note gnutls_certificate_allocate_credentials::

   * *note gnutls_certificate_free_credentials::

After the credentials structures are initialized, the certificate and
key pair must be loaded. This occurs before any TLS session is
initialized, and the same structures are reused for multiple sessions.
Depending on the certificate type different loading functions are
available, as shown below.  For X.509 certificates, the functions will
accept and use a certificate chain that leads to a trusted authority.
The certificate chain must be ordered in such way that every
certificate certifies the one before it. The trusted authority's
certificate need not to be included since the peer should possess it
already.

   * *note gnutls_certificate_set_x509_key_mem::

   * *note gnutls_certificate_set_x509_key::

   * *note gnutls_certificate_set_x509_key_file::

   * *note gnutls_certificate_set_openpgp_key_mem::

   * *note gnutls_certificate_set_openpgp_key::

   * *note gnutls_certificate_set_openpgp_key_file::

   * *note gnutls_certificate_set_key::

As an alternative to loading from files or buffers, a callback may be
used for the server or the client to specify the certificate and the
key at the handshake time.  In that case a certificate should be
selected according the peer's signature algorithm preferences. To get
those preferences use *note gnutls_sign_algorithm_get_requested::. Both
functions are shown below.

   * *note gnutls_certificate_set_retrieve_function::

   * *note gnutls_sign_algorithm_get_requested::

Certificate verification is possible by loading the trusted authorities
into the credentials structure by using the following functions,
applicable to X.509 and OpenPGP certificates.

   * *note gnutls_certificate_set_x509_trust_file::

   * *note gnutls_certificate_set_openpgp_keyring_file::

Note however that the peer's certificate is not automatically verified,
you should call *note gnutls_certificate_verify_peers2::, after a
successful handshake or during if *note
gnutls_certificate_set_verify_function:: has been used, to verify the
certificate's signature.  An alternative way, which reports a more
detailed verification output, is to use *note
gnutls_certificate_get_peers:: to obtain the raw certificate of the
peer and verify it using the functions discussed in *note X.509
certificates::.

   * *note gnutls_certificate_verify_peers2::

In a handshake, the negotiated cipher suite also depends on the
certificate's parameters, so some key exchange methods might not be
available with some certificates. GnuTLS will disable ciphersuites that
are not compatible with the key, or the enabled authentication methods.
For example keys marked as sign-only, will not be able to access the
plain RSA ciphersuites, that require decryption. It is not recommended
to use RSA keys for both signing and encryption. If possible use a
different key for the `DHE_RSA' which uses signing and `RSA' that
requires decryption.  All the key exchange methods shown in *note Table
3.4: tab:key-exchange. are available in certificate authentication.

   * *note gnutls_certificate_set_verify_function::

Note that the DHE key exchange methods are generally slower(1) than the
elliptic curves counterpart (ECDHE). Moreover the plain Diffie-Hellman
key exchange requires parameters to be generated and associated with a
credentials structure by the server (see *note Parameter generation::).

Client certificate authentication
.................................

If a certificate is to be requested from the client during the
handshake, the server will send a certificate request message. This
behavior is controlled *note gnutls_certificate_server_set_request::.
The request contains a list of the acceptable by the server certificate
signers. This list is constructed using the trusted certificate
authorities of the server.  In cases where the server supports a large
number of certificate authorities it makes sense not to advertise all
of the names to save bandwidth. That can be controlled using the
function *note gnutls_certificate_send_x509_rdn_sequence::.  This
however will have the side-effect of not restricting the client to
certificates signed by server's acceptable signers.

   * *note gnutls_certificate_server_set_request::

   * *note gnutls_certificate_send_x509_rdn_sequence::

---------- Footnotes ----------

(1) It depends on the group used.  Primes with lesser bits are always
faster, but also easier to break.  See *note Selecting cryptographic
key sizes:: for the acceptable security levels.


File: gnutls.info,  Node: SRP credentials,  Next: PSK credentials,  Prev: Certificate credentials,  Up: Associating the credentials

7.4.2 SRP
---------

The initialization functions in SRP credentials differ between client
and server.  Clients supporting SRP should set the username and password
prior to connection, to the credentials structure.  Alternatively *note
gnutls_srp_set_client_credentials_function:: may be used instead, to
specify a callback function that should return the SRP username and
password.  The callback is called once during the TLS handshake.

   * *note gnutls_srp_allocate_server_credentials::

   * *note gnutls_srp_allocate_client_credentials::

   * *note gnutls_srp_free_server_credentials::

   * *note gnutls_srp_free_client_credentials::

   * *note gnutls_srp_set_client_credentials::

   * *note gnutls_srp_set_client_credentials_function::

In server side the default behavior of GnuTLS is to read the usernames
and SRP verifiers from password files. These password file format is
compatible the with the _Stanford srp libraries_ format.  If a
different password file format is to be used, then *note
gnutls_srp_set_server_credentials_function:: should be called, to set
an appropriate callback.

   * *note gnutls_srp_set_server_credentials_file::

   * *note gnutls_srp_set_server_credentials_function::


File: gnutls.info,  Node: PSK credentials,  Next: Anonymous credentials,  Prev: SRP credentials,  Up: Associating the credentials

7.4.3 PSK
---------

The initialization functions in PSK credentials differ between client
and server.

   * *note gnutls_psk_allocate_server_credentials::

   * *note gnutls_psk_allocate_client_credentials::

   * *note gnutls_psk_free_server_credentials::

   * *note gnutls_psk_free_client_credentials::

Clients supporting PSK should supply the username and key before a TLS
session is established.  Alternatively *note
gnutls_psk_set_client_credentials_function:: can be used to specify a
callback function. This has the advantage that the callback will be
called only if PSK has been negotiated.

   * *note gnutls_psk_set_client_credentials::

   * *note gnutls_psk_set_client_credentials_function::

In server side the default behavior of GnuTLS is to read the usernames
and PSK keys from a password file. The password file should contain
usernames and keys in hexadecimal format. The name of the password file
can be stored to the credentials structure by calling *note
gnutls_psk_set_server_credentials_file::.  If a different password file
format is to be used, then a callback should be set instead by *note
gnutls_psk_set_server_credentials_function::.

The server can help the client chose a suitable username and password,
by sending a hint. Note that there is no common profile for the PSK
hint and applications are discouraged to use it.  A server, may specify
the hint by calling *note gnutls_psk_set_server_credentials_hint::.
The client can retrieve the hint, for example in the callback function,
using *note gnutls_psk_client_get_hint::.

   * *note gnutls_psk_set_server_credentials_file::

   * *note gnutls_psk_set_server_credentials_function::

   * *note gnutls_psk_set_server_credentials_hint::

   * *note gnutls_psk_client_get_hint::


File: gnutls.info,  Node: Anonymous credentials,  Prev: PSK credentials,  Up: Associating the credentials

7.4.4 Anonymous
---------------

The initialization functions for the credentials are shown below.

   * *note gnutls_anon_allocate_server_credentials::

   * *note gnutls_anon_allocate_client_credentials::

   * *note gnutls_anon_free_server_credentials::

   * *note gnutls_anon_free_client_credentials::

Note that the key exchange methods for anonymous authentication require
Diffie-Hellman parameters to be generated by the server and associated
with an anonymous credentials structure. Check *note Parameter
generation:: for more information.


File: gnutls.info,  Node: Setting up the transport layer,  Next: TLS handshake,  Prev: Associating the credentials,  Up: How to use GnuTLS in applications

7.5 Setting up the transport layer
==================================

The next step is to setup the underlying transport layer details. The
Berkeley sockets are implicitly used by GnuTLS, thus a call to *note
gnutls_transport_set_ptr2:: would be sufficient to specify the socket
descriptor.

   * *note gnutls_transport_set_ptr2::

   * *note gnutls_transport_set_ptr::

If however another transport layer than TCP is selected, then the
following functions have to be specified.

   * *note gnutls_transport_set_push_function::

   * *note gnutls_transport_set_vec_push_function::

   * *note gnutls_transport_set_pull_function::

The functions above accept a callback function which should return the
number of bytes written, or -1 on error and should set `errno'
appropriately.  In some environments, setting `errno' is unreliable.
For example Windows have several errno variables in different CRTs, or
in other systems it may be a non thread-local variable.  If this is a
concern to you, call *note gnutls_transport_set_errno:: with the
intended errno value instead of setting `errno' directly.

   * *note gnutls_transport_set_errno::

GnuTLS currently only interprets the EINTR and EAGAIN errno values and
returns the corresponding GnuTLS error codes:
   * `GNUTLS_E_INTERRUPTED'

   * `GNUTLS_E_AGAIN'
The EINTR and EAGAIN values are returned by interrupted system calls,
or when non blocking IO is used.  All GnuTLS functions can be resumed
(called again), if any of the above error codes is returned.

In the case of DTLS it is also desirable to override the generic
transport functions with functions that emulate the operation of
`recvfrom' and `sendto'. In addition DTLS requires timers during the
receive of a handshake message. This requires the *note
gnutls_transport_set_pull_timeout_function:: function to be used.

   * *note gnutls_transport_set_pull_timeout_function::

* Menu:

* Asynchronous operation::
* DTLS sessions::


File: gnutls.info,  Node: Asynchronous operation,  Next: DTLS sessions,  Up: Setting up the transport layer

7.5.1 Asynchronous operation
----------------------------

GnuTLS can be used with asynchronous socket or event-driven programming.
During a TLS protocol session GnuTLS does not block for anything except
calculations. The only blocking operations are due to the transport
layer (sockets) functions.  Those, however, in an asynchronous scenario
are typically set to non-blocking mode, which forces them to return
`EAGAIN' error code instead of blocking.  In that case GnuTLS functions
will return the `GNUTLS_E_AGAIN' error code and can be resumed the same
way as a system call would. The only exception is *note
gnutls_record_send::, which if interrupted subsequent calls need not to
include the data to be sent (can be called with NULL argument).

The `select' system call can also be used in combination with the
GnuTLS functions. `select' allows monitoring of sockets and notifies on
them being ready for reading or writing data. Note however that this
system call cannot notify on data present in GnuTLS read buffers, it is
only applicable to the kernel sockets API. Thus if you are using it for
reading from a GnuTLS session, make sure the session is read
completely. That can be achieved by checking there are no data waiting
to be read (using *note gnutls_record_check_pending::), either before
the `select' system call, or after a call to *note
gnutls_record_recv::. GnuTLS does not keep a write buffer, thus when
writing `select' need only to be consulted.

In the DTLS, however, GnuTLS might block due to timers required by the
protocol. To prevent those timers from blocking a DTLS handshake, the
*note gnutls_init:: should be called with the `GNUTLS_NONBLOCK' flag
(see *note Session initialization::).


File: gnutls.info,  Node: DTLS sessions,  Prev: Asynchronous operation,  Up: Setting up the transport layer

7.5.2 DTLS sessions
-------------------

Because datagram TLS can operate over connections where the peer of a
server cannot be reliably verified, functionality is available to
prevent denial of service attacks. GnuTLS requires a server to generate
a secret key that is used to sign a cookie(1).  That cookie is sent to
the client using *note gnutls_dtls_cookie_send::, and the client must
reply using the correct cookie. The server side should verify the
initial message sent by client using *note gnutls_dtls_cookie_verify::.
If successful the session should be initialized and associated with the
cookie using *note gnutls_dtls_prestate_set::, before proceeding to the
handshake.

   * *note gnutls_key_generate::

   * *note gnutls_dtls_cookie_send::

   * *note gnutls_dtls_cookie_verify::

   * *note gnutls_dtls_prestate_set::

Note that the above apply to server side only and they are not
mandatory to be used. Not using them, however, allows denial of service
attacks.  The client side cookie handling is part of *note
gnutls_handshake::.

Datagrams are typically restricted by a maximum transfer unit (MTU).
For that both client and server side should set the correct maximum
transfer unit for the layer underneath GnuTLS. This will allow proper
fragmentation of DTLS messages and prevent messages from being silently
discarded by the transport layer. The "correct" maximum transfer unit
can be obtained through a path MTU discovery mechanism [_RFC4821_].

   * *note gnutls_dtls_set_mtu::

   * *note gnutls_dtls_get_mtu::

   * *note gnutls_dtls_get_data_mtu::

---------- Footnotes ----------

(1) A key of 128 bits or 16 bytes should be sufficient for this purpose.


File: gnutls.info,  Node: TLS handshake,  Next: Data transfer and termination,  Prev: Setting up the transport layer,  Up: How to use GnuTLS in applications

7.6 TLS handshake
=================

Once a session has been initialized and a network connection has been
set up, TLS and DTLS protocols perform a handshake. The handshake is
the actual key exchange.

   * *note gnutls_handshake::

The handshake process doesn't ensure the verification of the peer's
identity. When certificates are in use, this can be done, either after
the handshake is complete, or during the handshake if *note
gnutls_certificate_set_verify_function:: has been used. In both cases
the *note gnutls_certificate_verify_peers2:: function can be used to
verify the peer's certificate (see *note Certificate authentication::
for more information).

   * *note gnutls_certificate_verify_peers2::


File: gnutls.info,  Node: Data transfer and termination,  Next: Priority Strings,  Prev: TLS handshake,  Up: How to use GnuTLS in applications

7.7 Data transfer and termination
=================================

Once the handshake is complete and peer's identity has been verified
data can be exchanged. The available functions resemble the POSIX
`recv' and `send' functions. It is suggested to use *note
gnutls_error_is_fatal:: to check whether the error codes returned by
these functions are fatal for the protocol or can be ignored.

   * *note gnutls_record_send::

   * *note gnutls_record_recv::

   * *note gnutls_error_is_fatal::

In DTLS it is adviceable to use the extended receive function shown
below, because it allows the extraction of the sequence number. This is
required in DTLS because messages may arrive out of order.

   * *note gnutls_record_recv_seq::

The *note gnutls_record_check_pending:: helper function is available to
allow checking whether data are available to be read in a GnuTLS session
buffers. Note that this function complements but does not replace
`select', i.e., *note gnutls_record_check_pending:: reports no data to
be read, `select' should be called to check for data in the network
buffers.

   * *note gnutls_record_check_pending::

   * *note gnutls_record_get_direction::

Once a TLS or DTLS session is no longer needed, it is recommended to
use *note gnutls_bye:: to terminate the session. That way the peer is
notified securely about the intention of termination, which allows
distinguishing it from a malicious connection termination.  A session
can be deinitialized with the *note gnutls_deinit:: function.

   * *note gnutls_bye::

   * *note gnutls_deinit::


File: gnutls.info,  Node: Priority Strings,  Next: Advanced and other topics,  Prev: Data transfer and termination,  Up: How to use GnuTLS in applications

7.8 Priority strings
====================

In order to specify cipher suite preferences on a TLS session there are
priority functions that accept a string specifying the enabled for the
handshake algorithms.  That string may contain a high level keyword
such as in *note tab:prio-keywords:: or combination of a high level
keyword, additional algorithm keywords and special keywords.

   * *note gnutls_priority_set_direct::

   * *note gnutls_priority_set::

Keyword        Description
------------------------------------------------------------------ 
PERFORMANCE     All the "secure" ciphersuites are enabled,
               limited to 128 bit ciphers and sorted by terms of
               speed performance.
NORMAL          Means all "secure" ciphersuites. The 256-bit
               ciphers are included as a fallback only.  The
               ciphers are sorted by security margin.
SECURE128       Means all "secure" ciphersuites of security
               level 128-bit or more.
SECURE192       Means all "secure" ciphersuites of security
               level 192-bit or more.
SECURE256       Currently alias for SECURE192.
SUITEB128       Means all the NSA Suite B cryptography (RFC5430)
               ciphersuites with an 128 bit security level.
SUITEB192       Means all the NSA Suite B cryptography (RFC5430)
               ciphersuites with an 192 bit security level.
EXPORT          Means all ciphersuites are enabled, including the
               low-security 40 bit ciphers.
NONE            Means nothing is enabled.  This disables even
               protocols and compression methods. It should be
               followed by the algorithms to be enabled.

Table 7.1: Supported priority string keywords.

Unless the first keyword is "NONE" the defaults (in preference order)
are for TLS protocols TLS 1.2, TLS1.1, TLS1.0, SSL3.0; for compression
NULL; for certificate types X.509.  In key exchange algorithms when in
NORMAL or SECURE levels the perfect forward secrecy algorithms take
precedence of the other protocols.  In all cases all the supported key
exchange algorithms  are enabled (except for the RSA-EXPORT which is
only enabled in EXPORT level).  The NONE keyword, if used, must
followed by the algorithms to be enabled, and is used to provide the
exact list of requested algorithms(1). The order with which every
algorithm is specified is significant. Similar algorithms specified
before others will take precedence. The individual algorithms are shown
in *note tab:prio-algorithms:: and special keywords are in *note
tab:prio-special::.  The prefixes for individual algorithms are:
'!' or '-'
     appended with an algorithm will remove this algorithm.

"+"
     appended with an algorithm will add this algorithm.

Type           Keywords
------------------------------------------------------------------ 
Ciphers         AES-128-CBC, AES-256-CBC, AES-128-GCM,
               CAMELLIA-128-CBC, CAMELLIA-256-CBC, ARCFOUR-128,
               3DES-CBC ARCFOUR-40. Catch all name is CIPHER-ALL
               which will add all the algorithms from NORMAL
               priority.
Key exchange    RSA, DHE-RSA, DHE-DSS, SRP, SRP-RSA, SRP-DSS,
               PSK, DHE-PSK, ECDHE-RSA, ANON-ECDH, ANON-DH,
               RSA-EXPORT. The Catch all name is KX-ALL which
               will add all the algorithms from NORMAL priority.
MAC             MD5, SHA1, SHA256, AEAD (used with GCM ciphers
               only). All algorithms from NORMAL priority can be
               accessed with MAC-ALL.
Compression     COMP-NULL, COMP-DEFLATE. Catch all is COMP-ALL.
algorithms     
TLS versions    VERS-SSL3.0, VERS-TLS1.0, VERS-TLS1.1,
               VERS-TLS1.2. Catch all is VERS-TLS-ALL.
Signature       SIGN-RSA-SHA1, SIGN-RSA-SHA224, SIGN-RSA-SHA256,
algorithms     SIGN-RSA-SHA384, SIGN-RSA-SHA512, SIGN-DSA-SHA1,
               SIGN-DSA-SHA224, SIGN-DSA-SHA256, SIGN-RSA-MD5.
               Catch all is SIGN-ALL. This is only valid for TLS
               1.2 and later.
Elliptic        CURVE-SECP224R1, CURVE-SECP256R1,
curves         CURVE-SECP384R1, CURVE-SECP521R1. Catch all is
               CURVE-ALL.

Table 7.2: The supported algorithm keywords in priority strings.

Keyword                          Description
------------------------------------------------------------------ 
%COMPAT                           will enable compatibility
                                 mode. It might mean that
                                 violations of the protocols are
                                 allowed as long as maximum
                                 compatibility with problematic
                                 clients and servers is achieved.
%NO_EXTENSIONS                    will prevent the sending of
                                 any TLS extensions in client
                                 side. Note that TLS 1.2
                                 requires extensions to be used,
                                 as well as safe renegotiation
                                 thus this option must be used
                                 with care.
%SERVER_PRECEDENCE                The ciphersuite will be
                                 selected according to server
                                 priorities and not the client's.
%DISABLE_SAFE_RENEGOTIATION       will disable safe renegotiation
                                 completely.  Do not use unless
                                 you know what you are doing.
                                 Testing purposes only.
%UNSAFE_RENEGOTIATION             will allow handshakes and
                                 re-handshakes without the safe
                                 renegotiation extension.  Note
                                 that for clients this mode is
                                 insecure (you may be under
                                 attack), and for servers it
                                 will allow insecure clients to
                                 connect (which could be fooled
                                 by an attacker).  Do not use
                                 unless you know what you are
                                 doing and want maximum
                                 compatibility.
%PARTIAL_RENEGOTIATION            will allow initial handshakes
                                 to proceed, but not
                                 re-handshakes.  This leaves the
                                 client vulnerable to attack,
                                 and servers will be compatible
                                 with non-upgraded clients for
                                 initial handshakes.  This is
                                 currently the default for
                                 clients and servers, for
                                 compatibility reasons.
%SAFE_RENEGOTIATION               will enforce safe
                                 renegotiation.  Clients and
                                 servers will refuse to talk to
                                 an insecure peer.  Currently
                                 this causes interoperability
                                 problems, but is required for
                                 full protection.
%SSL3_RECORD_VERSION              will use SSL3.0 record version
                                 in client hello.  This is the
                                 default.
%LATEST_RECORD_VERSION            will use the latest TLS
                                 version record version in
                                 client hello.
%VERIFY_ALLOW_SIGN_RSA_MD5        will allow RSA-MD5 signatures
                                 in certificate chains.
%VERIFY_ALLOW_X509_V1_CA_CRT      will allow V1 CAs in chains.

Table 7.3: Special priority string keywords.

---------- Footnotes ----------

(1) To avoid collisions in order to specify a compression algorithm in
this string you have to prefix it with "COMP-", protocol versions with
"VERS-", signature algorithms with "SIGN-" and certificate types with
"CTYPE-". All other algorithms don't need a prefix.


File: gnutls.info,  Node: Advanced and other topics,  Next: Using the cryptographic library,  Prev: Priority Strings,  Up: How to use GnuTLS in applications

7.9 Advanced and other topics
=============================

* Menu:

* Session resumption::
* Parameter generation::
* Keying Material Exporters::
* Channel Bindings::
* Interoperability::
* Compatibility with the OpenSSL library::


File: gnutls.info,  Node: Session resumption,  Next: Parameter generation,  Up: Advanced and other topics

7.9.1 Session resumption
------------------------

Client side
...........

To reduce time and roundtrips spent in a handshake the client can
utilize session resumption. This requires the client to retrieve and
store the session parameters. On new sessions to the same server the
parameters must be re-associated with sessions using *note
gnutls_session_set_data::.

   * *note gnutls_session_get_data::

   * *note gnutls_session_get_id::

   * *note gnutls_session_set_data::

Keep in mind that sessions might be expired after some time, and it may
be normal for a server not to resume a session even it was requested.
That is to prevent temporal session keys from becoming long-term keys.
Also note that as a client you must enable, using the priority
functions, at least the algorithms used in the last session.

It is highly recommended clients to enable the session ticket extension
using *note gnutls_session_ticket_enable_client:: in order to allow
resumption with servers that do not store any state.

   * *note gnutls_session_ticket_enable_client::

Server side
...........

In order to support resumption a server might do it either by storing
the session security parameters in a local database or by using session
tickets (see *note Session tickets::) to delegate storage to the
client. Because session tickets might not be supported by all clients,
servers might combine the two methods.

A storing server needs to specify callback functions to store, retrieve
and delete session data. These can be registered with the functions
below. The stored sessions in the database can be checked using *note
gnutls_db_check_entry:: for expiration.

   * *note gnutls_db_set_retrieve_function::

   * *note gnutls_db_set_store_function::

   * *note gnutls_db_set_ptr::

   * *note gnutls_db_set_remove_function::

   * *note gnutls_db_check_entry::

A server utilizing tickets should use *note
gnutls_session_ticket_key_generate:: to generate a ticket encryption
key and call *note gnutls_session_ticket_enable_server:: to enable the
extension.

   * *note gnutls_session_ticket_enable_server::

   * *note gnutls_session_ticket_key_generate::


File: gnutls.info,  Node: Parameter generation,  Next: Keying Material Exporters,  Prev: Session resumption,  Up: Advanced and other topics

7.9.2 Parameter generation
--------------------------

Several TLS ciphersuites require additional parameters that need to be
generated or provided by the application. The Diffie-Hellman based
ciphersuites (ANON-DH or DHE), require the group parameters to be
provided. Those can either be be generated on the fly using *note
gnutls_dh_params_generate2:: or imported from pregenerated data using
*note gnutls_dh_params_import_pkcs3::.  The parameters can be used in a
TLS session by calling *note gnutls_certificate_set_dh_params:: or
*note gnutls_anon_set_server_dh_params:: for anonymous sessions.

   * *note gnutls_dh_params_generate2::

   * *note gnutls_dh_params_import_pkcs3::

   * *note gnutls_certificate_set_dh_params::

   * *note gnutls_anon_set_server_dh_params::

Due to the time-consuming calculations required for the generation of
Diffie-Hellman parameters we suggest against performing generation of
them within an application. The `certtool' tool can be used to generate
or export known safe values that can be stored in code or in a
configuration file to provide the ability to replace. We also recommend
the usage of *note gnutls_sec_param_to_pk_bits:: (see *note Selecting
cryptographic key sizes::) to determine the bit size of the generated
parameters.

The ciphersuites that involve the RSA-EXPORT key exchange require
additional parameters. Those ciphersuites are rarely used today because
they are by design insecure, thus if you have no requirement for them,
the rest of this section can be skipped. The RSA-EXPORT key exchange
requires 512-bit RSA keys to be generated. It is recommended those
parameters to be refreshed (regenerated) in short intervals. The
following functions can be used for these parameters.

   * *note gnutls_rsa_params_generate2::

   * *note gnutls_certificate_set_rsa_export_params::

   * *note gnutls_rsa_params_import_pkcs1::

   * *note gnutls_rsa_params_export_pkcs1::

To allow renewal of the parameters within an application without
accessing the credentials, which are a shared structure, an alternative
interface is available using a callback function.

   * *note gnutls_certificate_set_params_function::


File: gnutls.info,  Node: Keying Material Exporters,  Next: Channel Bindings,  Prev: Parameter generation,  Up: Advanced and other topics

7.9.3 Keying material exporters
-------------------------------

The TLS PRF can be used by other protocols to derive data.  The API to
use is *note gnutls_prf::.  The function needs to be provided with the
label in the parameter `label', and the extra data to mix in the
`extra' parameter.  Depending on whether you want to mix in the client
or server random data first, you can set the `server_random_first'
parameter.

For example, after establishing a TLS session using *note
gnutls_handshake::, you can invoke the TLS PRF with this call:

     #define MYLABEL "EXPORTER-FOO"
     #define MYCONTEXT "some context data"
     char out[32];
     rc = gnutls_prf (session, strlen (MYLABEL), MYLABEL, 0,
                      strlen (MYCONTEXT), MYCONTEXT, 32, out);

If you don't want to mix in the client/server random, there is a more
low-level TLS PRF interface called *note gnutls_prf_raw::.


File: gnutls.info,  Node: Channel Bindings,  Next: Interoperability,  Prev: Keying Material Exporters,  Up: Advanced and other topics

7.9.4 Channel bindings
----------------------

In user authentication protocols (e.g., EAP or SASL mechanisms) it is
useful to have a unique string that identifies the secure channel that
is used, to bind together the user authentication with the secure
channel.  This can protect against man-in-the-middle attacks in some
situations.  That unique string is called a "channel binding".  For
background and discussion see [_RFC5056_].

In GnuTLS you can extract a channel binding using the *note
gnutls_session_channel_binding:: function.  Currently only the type
`GNUTLS_CB_TLS_UNIQUE' is supported, which corresponds to the
`tls-unique' channel binding for TLS defined in [_RFC5929_].

The following example describes how to print the channel binding data.
Note that it must be run after a successful TLS handshake.

     {
       gnutls_datum_t cb;
       int rc;

       rc = gnutls_session_channel_binding (session,
                                            GNUTLS_CB_TLS_UNIQUE,
                                            &cb);
       if (rc)
         fprintf (stderr, "Channel binding error: %s\n",
                  gnutls_strerror (rc));
       else
         {
           size_t i;
           printf ("- Channel binding 'tls-unique': ");
           for (i = 0; i < cb.size; i++)
             printf ("%02x", cb.data[i]);
           printf ("\n");
         }
     }


File: gnutls.info,  Node: Interoperability,  Next: Compatibility with the OpenSSL library,  Prev: Channel Bindings,  Up: Advanced and other topics

7.9.5 Interoperability
----------------------

The TLS protocols support many ciphersuites, extensions and version
numbers. As a result, few implementations are not able to properly
interoperate once faced with extensions or version protocols they do
not support and understand. The TLS protocol allows for a graceful
downgrade to the commonly supported options, but practice shows it is
not always implemented correctly.

Because there is no way to achieve maximum interoperability with broken
peers without sacrificing security, GnuTLS ignores such peers by
default.  This might not be acceptable in cases where maximum
compatibility is required. Thus we allow enabling compatibility with
broken peers using priority strings (see *note Priority Strings::). An
example priority string that is known to provide wide compatibility
even with broken peers is shown below:
NORMAL:-VERS-TLS-ALL:+VERS-TLS1.0:+VERS-SSL3.0:%COMPAT
 This priority string will only enable SSL 3.0 and TLS 1.0 as protocols
and will disable, via the `%COMPAT' keyword, several TLS protocol
options that are known to cause compatibility problems. Note however
that there are known attacks against those protocol versions and this
mode trades security for compatibility.


File: gnutls.info,  Node: Compatibility with the OpenSSL library,  Prev: Interoperability,  Up: Advanced and other topics

7.9.6 Compatibility with the OpenSSL library
--------------------------------------------

To ease GnuTLS' integration with existing applications, a compatibility
layer with the OpenSSL library is included in the `gnutls-openssl'
library. This compatibility layer is not complete and it is not
intended to completely re-implement the OpenSSL API with GnuTLS.  It
only provides limited source-level compatibility.

The prototypes for the compatibility functions are in the
`gnutls/openssl.h' header file. The limitations imposed by the
compatibility layer include:

   * Error handling is not thread safe.



File: gnutls.info,  Node: Using the cryptographic library,  Next: Selecting cryptographic key sizes,  Prev: Advanced and other topics,  Up: How to use GnuTLS in applications

7.10 Using the cryptographic library
====================================

GnuTLS is not a low-level cryptographic library, i.e., it does not
provide access to basic cryptographic primitives. However it abstracts
the internal cryptographic back-end (see *note Cryptographic Backend::),
providing symmetric crypto, hash and HMAC algorithms, as well access to
the random number generation.

* Menu:

* Symmetric cryptography::
* Hash and HMAC functions::
* Random number generation::


File: gnutls.info,  Node: Symmetric cryptography,  Next: Hash and HMAC functions,  Up: Using the cryptographic library

7.10.1 Symmetric cryptography
-----------------------------

The available functions to access symmetric crypto algorithms operations
are shown below. The supported algorithms are the algorithms required
by the TLS protocol.  They are listed in *note Table 3.1: tab:ciphers.

   * *note gnutls_cipher_init::

   * *note gnutls_cipher_encrypt2::

   * *note gnutls_cipher_decrypt2::

   * *note gnutls_cipher_set_iv::

   * *note gnutls_cipher_deinit::

In order to support authenticated encryption with associated data
(AEAD) algorithms the following functions are provided to set the
associated data and retrieve the authentication tag.

   * *note gnutls_cipher_add_auth::

   * *note gnutls_cipher_tag::


File: gnutls.info,  Node: Hash and HMAC functions,  Next: Random number generation,  Prev: Symmetric cryptography,  Up: Using the cryptographic library

7.10.2 Hash and HMAC functions
------------------------------

The available operations to access hash functions and hash-MAC (HMAC)
algorithms are shown below. HMAC algorithms provided keyed hash
functionality. They supported HMAC algorithms are listed in *note Table
3.2: tab:macs.

   * *note gnutls_hmac_init::

   * *note gnutls_hmac::

   * *note gnutls_hmac_output::

   * *note gnutls_hmac_deinit::

   * *note gnutls_hmac_get_len::

   * *note gnutls_hmac_fast::

The available functions to access hash functions are shown below. The
supported hash functions are the same as the HMAC algorithms.

   * *note gnutls_hash_init::

   * *note gnutls_hash::

   * *note gnutls_hash_output::

   * *note gnutls_hash_deinit::

   * *note gnutls_hash_get_len::

   * *note gnutls_hash_fast::


File: gnutls.info,  Node: Random number generation,  Prev: Hash and HMAC functions,  Up: Using the cryptographic library

7.10.3 Random number generation
-------------------------------

Access to the random number generator is provided using the *note
gnutls_rnd:: function. It allows obtaining random data of various
levels.

   * GNUTLS_RND_NONCE Non-predictable random number.  Fatal in parts of
     session if broken, i.e., vulnerable to statistical analysis.

   * GNUTLS_RND_RANDOM Pseudo-random cryptographic random number.
     Fatal in session if broken.

   * GNUTLS_RND_KEY Fatal in many sessions if broken.

Table 7.4

   * *note gnutls_rnd::


File: gnutls.info,  Node: Selecting cryptographic key sizes,  Prev: Using the cryptographic library,  Up: How to use GnuTLS in applications

7.11 Selecting cryptographic key sizes
======================================

Because many algorithms are involved in TLS, it is not easy to set a
consistent security level.  For this reason in *note tab:key-sizes:: we
present some correspondence between key sizes of symmetric algorithms
and public key algorithms based on [_ECRYPT_].  Those can be used to
generate certificates with appropriate key sizes as well as select
parameters for Diffie-Hellman and SRP authentication.

SecurityRSA, DH   ECC     Security       Description
bits    and SRP   key     parameter      
        parameter size                   
        size                             
----------------------------------------------------------------- 
64      816       128     `WEAK'         Very short term
                                         protection against
                                         small organizations
80      1248      160     `LOW'          Very short term
                                         protection against
                                         agencies
112     2432      224     `NORMAL'       Medium-term protection
128     3248      256     `HIGH'         Long term protection
256     15424     512     `ULTRA'        Foreseeable future

Table 7.5: Key sizes and security parameters.

The first column  provides a security parameter in a number of bits.
This gives an indication of the number of combinations to be tried by
an adversary to brute force a key. For example to test all possible
keys in a 112 bit security parameter 2^112 combinations have to be
tried. For today's technology this is infeasible.  The next two columns
correlate the security parameter with actual bit sizes of parameters
for DH, RSA, SRP and ECC algorithms.  A mapping to `gnutls_sec_param_t'
value is given for each security parameter, on the next column, and
finally a brief description of the level.

Note, however, that the values suggested here are nothing more than an
educated guess that is valid today. There are no guarantees that an
algorithm will remain unbreakable or that these values will remain
constant in time. There could be scientific breakthroughs that cannot
be predicted or total failure of the current public key systems by
quantum computers. On the other hand though the cryptosystems used in
TLS are selected in a conservative way and such catastrophic
breakthroughs or failures are believed to be unlikely.  The NIST
publication SP 800-57 [_NISTSP80057_] contains a similar table.

When using GnuTLS and a decision on bit sizes for a public key
algorithm is required, use of the following functions is recommended:

   * *note gnutls_sec_param_to_pk_bits::

   * *note gnutls_pk_bits_to_sec_param::

Those functions will convert a human understandable security parameter
of `gnutls_sec_param_t' type, to a number of bits suitable for a public
key algorithm.


File: gnutls.info,  Node: GnuTLS application examples,  Next: Other included programs,  Prev: How to use GnuTLS in applications,  Up: Top

8 GnuTLS application examples
*****************************

* Menu:

* Client examples::
* Server examples::
* Miscellaneous examples::


File: gnutls.info,  Node: Client examples,  Next: Server examples,  Up: GnuTLS application examples

8.1 Client examples
===================

This section contains examples of TLS and SSL clients, using GnuTLS.
Note that these examples contain little or no error checking.  Some of
the examples require functions implemented by another example.

* Menu:

* Simple client example with anonymous authentication::
* Simple client example with X.509 certificate support::
* Simple Datagram TLS client example::
* Obtaining session information::
* Using a callback to select the certificate to use::
* Verifying a certificate::
* Client using a PKCS 11 token with TLS::
* Client with Resume capability example::
* Simple client example with SRP authentication::
* Simple client example in C++::
* Helper function for TCP connections::


File: gnutls.info,  Node: Simple client example with anonymous authentication,  Next: Simple client example with X.509 certificate support,  Up: Client examples

8.1.1 Simple client example with anonymous authentication
---------------------------------------------------------

The simplest client using TLS is the one that doesn't do any
authentication.  This means no external certificates or passwords are
needed to set up the connection.  As could be expected, the connection
is vulnerable to man-in-the-middle (active or redirection) attacks.
However, the data is integrity and privacy protected.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>
#include "examples.h"
#include "get_ip.c"

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification.
 */

#define MAX_BUF 1024
#define CAFILE "cacert.pem"
#define MSG "PROJECT DEADLINE : MAR 23 :P"

extern int tcp_connect (void);
extern void tcp_close (int sd);
static int _verify_certificate_callback (gnutls_session_t session);

int
tcp_connect (void)
{
  const char *PORT = "5557";
  const char *SERVER = "127.0.0.1";
  int err, sd;
  struct sockaddr_in sa;

  /* connects to server
   */
  sd = socket (AF_INET, SOCK_STREAM, 0);

  memset (&sa, '\0', sizeof (sa));
  sa.sin_family = AF_INET;
  sa.sin_port = htons (atoi (PORT));
  inet_pton (AF_INET, SERVER, &sa.sin_addr);

  err = connect (sd, (struct sockaddr *) & sa, sizeof (sa));
  if (err < 0)
    {
      fprintf (stderr, "Connect error\n");
      exit (1);
    }

  return sd;
}

/* closes the given socket descriptor.
 */
void
tcp_close (int sd)
{
  shutdown (sd, SHUT_RDWR);     /* no more receptions */
  close (sd);
}



void print_proxy_info(void* data,int data_length){
printf("\nGot Proxy_Info, Total data packet length:%d\n",data_length);
for (int i=0;i<data_length;i+=4){
if(i%20==0)
	printf("Proxy - %d:\nEncryption ALgorithm : %u\n",(i/12)+1,*(int*)(data+i));
if(i%20==4)
	printf("Key Exchange ALgorithm : %u\n",*(int*)(data+i));
if(i%20==8)
	printf("MAC ALgorithm : %u\n",*(int*)(data+i));
if(i%20==12){
char *p1=malloc(100);
int ip=*(int*)(data+i);
get_ip_str(ip,p1);
printf("IP Address : %s\n",p1);
}
if(i%20==16){
printf("MAC Address : %u\n\n",*(int*)(data+i));
}
}
}
int main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  //int data_length=0;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;
  gnutls_global_set_log_level(3);
  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, _verify_certificate_callback);

  /* If client holds a certificate it can be set using the following:
   */
     gnutls_certificate_set_x509_key_file (xcred,
                                           "clientcert.pem", "clientkey.pem",
                                           GNUTLS_X509_FMT_PEM);

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_SERVER);

  gnutls_session_set_ptr (session, (void *) "karthik");

//gnutls_ProxyInfo_ext t[3];

//karthik:Dummy generation but actually retrieved from the call to gnutls_foobar_get() in previous TLS session

  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &err);
  if (ret < 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);
  printf("Certificate credentials set\n");

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */

  ret = gnutls_handshake (session);
void *data=malloc(200);
size_t data_length=200;
unsigned int type;
gnutls_proxyinfo_get (session,data,&data_length,&type,0);
print_proxy_info(data,data_length);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {

      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);
while(1){}
 // gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}

/* This function will verify the peer's certificate, and check
 * if the hostname matches, as well as the activation, expiration dates.
 */
static int
_verify_certificate_callback (gnutls_session_t session)
{
  unsigned int status;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size;
  int ret;
  gnutls_x509_crt_t cert;
  const char *hostname;

  /* read hostname */
  hostname = gnutls_session_get_ptr (session);

  /* This verification function uses the trusted CAs in the credentials
   * structure. So you must have installed one or more CA certificates.
   */
  ret = gnutls_certificate_verify_peers2 (session, &status);
  if (ret < 0)
    {
      printf ("Error\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  if (status & GNUTLS_CERT_INVALID)
    printf ("The certificate is not trusted.\n");

  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
    printf ("The certificate hasn't got a known issuer.\n");

  if (status & GNUTLS_CERT_REVOKED)
    printf ("The certificate has been revoked.\n");

  if (status & GNUTLS_CERT_EXPIRED)
    printf ("The certificate has expired\n");

  if (status & GNUTLS_CERT_NOT_ACTIVATED)
    printf ("The certificate is not yet activated\n");

  /* Up to here the process is the same for X.509 certificates and
   * OpenPGP keys. From now on X.509 certificates are assumed. This can
   * be easily extended to work with openpgp keys as well.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return GNUTLS_E_CERTIFICATE_ERROR;

  if (gnutls_x509_crt_init (&cert) < 0)
    {
      printf ("error in initialization\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);
  if (cert_list == NULL)
    {
      printf ("No certificate was found!\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  /* This is not a real world example, since we only check the first
   * certificate in the given chain.
   */
  if (gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)
    {
      printf ("error parsing certificate\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }


  if (!gnutls_x509_crt_check_hostname (cert, hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  gnutls_x509_crt_deinit (cert);

  /* notify gnutls to continue handshake normally */
  return 0;
}


File: gnutls.info,  Node: Simple client example with X.509 certificate support,  Next: Simple Datagram TLS client example,  Prev: Simple client example with anonymous authentication,  Up: Client examples

8.1.2 Simple client example with X.509 certificate support
----------------------------------------------------------

Let's assume now that we want to create a TCP client which communicates
with servers that use X.509 or OpenPGP certificate authentication. The
following client is a very simple TLS client, which uses the high level
verification functions for certificates, but does not support session
resumption.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>
#include "examples.h"

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification.
 */

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern int tcp_connect (void);
extern void tcp_close (int sd);
static int _verify_certificate_callback (gnutls_session_t session);

int main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, _verify_certificate_callback);

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_CLIENT);

  gnutls_session_set_ptr (session, (void *) "my_host_name");

  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &err);
  if (ret < 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}

/* This function will verify the peer's certificate, and check
 * if the hostname matches, as well as the activation, expiration dates.
 */
static int
_verify_certificate_callback (gnutls_session_t session)
{
  unsigned int status;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size;
  int ret;
  gnutls_x509_crt_t cert;
  const char *hostname;

  /* read hostname */
  hostname = gnutls_session_get_ptr (session);

  /* This verification function uses the trusted CAs in the credentials
   * structure. So you must have installed one or more CA certificates.
   */
  ret = gnutls_certificate_verify_peers2 (session, &status);
  if (ret < 0)
    {
      printf ("Error\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  if (status & GNUTLS_CERT_INVALID)
    printf ("The certificate is not trusted.\n");

  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
    printf ("The certificate hasn't got a known issuer.\n");

  if (status & GNUTLS_CERT_REVOKED)
    printf ("The certificate has been revoked.\n");

  if (status & GNUTLS_CERT_EXPIRED)
    printf ("The certificate has expired\n");

  if (status & GNUTLS_CERT_NOT_ACTIVATED)
    printf ("The certificate is not yet activated\n");

  /* Up to here the process is the same for X.509 certificates and
   * OpenPGP keys. From now on X.509 certificates are assumed. This can
   * be easily extended to work with openpgp keys as well.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return GNUTLS_E_CERTIFICATE_ERROR;

  if (gnutls_x509_crt_init (&cert) < 0)
    {
      printf ("error in initialization\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);
  if (cert_list == NULL)
    {
      printf ("No certificate was found!\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  /* This is not a real world example, since we only check the first
   * certificate in the given chain.
   */
  if (gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)
    {
      printf ("error parsing certificate\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }


  if (!gnutls_x509_crt_check_hostname (cert, hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  gnutls_x509_crt_deinit (cert);

  /* notify gnutls to continue handshake normally */
  return 0;
}


File: gnutls.info,  Node: Simple Datagram TLS client example,  Next: Obtaining session information,  Prev: Simple client example with X.509 certificate support,  Up: Client examples

8.1.3 Simple datagram TLS client example
----------------------------------------

This is a client that uses UDP to connect to a server. This is the DTLS
equivalent to the example in *note Simple client example with X.509
certificate support::.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#include <gnutls/dtls.h>

/* A very basic Datagram TLS client, over UDP with X.509 authentication.
 */

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern int udp_connect (void);
extern void udp_close (int sd);
extern int verify_certificate_callback (gnutls_session_t session);

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* sets the trusted cas file */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, verify_certificate_callback);

  /* Initialize TLS session */
  gnutls_init (&session, GNUTLS_CLIENT | GNUTLS_DATAGRAM);

  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &err);
  if (ret < 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer */
  sd = udp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* set the connection MTU */
  gnutls_dtls_set_mtu (session, 1000);

  /* Perform the TLS handshake */
  ret = gnutls_handshake (session);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  /* It is suggested not to use GNUTLS_SHUT_RDWR in DTLS
   * connections because the peer's closure message might
   * be lost */
  gnutls_bye (session, GNUTLS_SHUT_WR);

end:

  udp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}


File: gnutls.info,  Node: Obtaining session information,  Next: Using a callback to select the certificate to use,  Prev: Simple Datagram TLS client example,  Up: Client examples

8.1.4 Obtaining session information
-----------------------------------

Most of the times it is desirable to know the security properties of
the current established session.  This includes the underlying ciphers
and the protocols involved.  That is the purpose of the following
function.  Note that this function will print meaningful values only if
called after a successful *note gnutls_handshake::.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>

#include "examples.h"

/* This function will print some details of the
 * given session.
 */
int
print_info (gnutls_session_t session)
{
  const char *tmp;
  gnutls_credentials_type_t cred;
  gnutls_kx_algorithm_t kx;
  int dhe, ecdh;

  dhe = ecdh = 0;

  /* print the key exchange's algorithm name
   */
  kx = gnutls_kx_get (session);
  tmp = gnutls_kx_get_name (kx);
  printf ("- Key Exchange: %s\n", tmp);

  /* Check the authentication type used and switch
   * to the appropriate.
   */
  cred = gnutls_auth_get_type (session);
  switch (cred)
    {
    case GNUTLS_CRD_IA:
      printf ("- TLS/IA session\n");
      break;


#ifdef ENABLE_SRP
    case GNUTLS_CRD_SRP:
      printf ("- SRP session with username %s\n",
              gnutls_srp_server_get_username (session));
      break;
#endif

    case GNUTLS_CRD_PSK:
      /* This returns NULL in server side.
       */
      if (gnutls_psk_client_get_hint (session) != NULL)
        printf ("- PSK authentication. PSK hint '%s'\n",
                gnutls_psk_client_get_hint (session));
      /* This returns NULL in client side.
       */
      if (gnutls_psk_server_get_username (session) != NULL)
        printf ("- PSK authentication. Connected as '%s'\n",
                gnutls_psk_server_get_username (session));

      if (kx == GNUTLS_KX_ECDHE_PSK)
        ecdh = 1;
      else if (kx == GNUTLS_KX_DHE_PSK)
        dhe = 1;
      break;

    case GNUTLS_CRD_ANON:      /* anonymous authentication */

      printf ("- Anonymous authentication.\n");
      if (kx == GNUTLS_KX_ANON_ECDH)
        ecdh = 1;
      else if (kx == GNUTLS_KX_ANON_DH)
        dhe = 1;
      break;

    case GNUTLS_CRD_CERTIFICATE:       /* certificate authentication */

      /* Check if we have been using ephemeral Diffie-Hellman.
       */
      if (kx == GNUTLS_KX_DHE_RSA || kx == GNUTLS_KX_DHE_DSS)
        dhe = 1;
      else if (kx == GNUTLS_KX_ECDHE_RSA || kx == GNUTLS_KX_ECDHE_ECDSA)
        ecdh = 1;

      /* if the certificate list is available, then
       * print some information about it.
       */
      print_x509_certificate_info (session);

    }                           /* switch */

  if (ecdh != 0)
    printf ("- Ephemeral ECDH using curve %s\n",
            gnutls_ecc_curve_get_name (gnutls_ecc_curve_get (session)));
  else if (dhe != 0)
    printf ("- Ephemeral DH using prime of %d bits\n",
            gnutls_dh_get_prime_bits (session));

  /* print the protocol's name (ie TLS 1.0)
   */
  tmp = gnutls_protocol_get_name (gnutls_protocol_get_version (session));
  printf ("- Protocol: %s\n", tmp);

  /* print the certificate type of the peer.
   * ie X.509
   */
  tmp =
    gnutls_certificate_type_get_name (gnutls_certificate_type_get (session));

  printf ("- Certificate Type: %s\n", tmp);

  /* print the compression algorithm (if any)
   */
  tmp = gnutls_compression_get_name (gnutls_compression_get (session));
  printf ("- Compression: %s\n", tmp);

  /* print the name of the cipher used.
   * ie 3DES.
   */
  tmp = gnutls_cipher_get_name (gnutls_cipher_get (session));
  printf ("- Cipher: %s\n", tmp);

  /* Print the MAC algorithms name.
   * ie SHA1
   */
  tmp = gnutls_mac_get_name (gnutls_mac_get (session));
  printf ("- MAC: %s\n", tmp);

  return 0;
}


File: gnutls.info,  Node: Using a callback to select the certificate to use,  Next: Verifying a certificate,  Prev: Obtaining session information,  Up: Client examples

8.1.5 Using a callback to select the certificate to use
-------------------------------------------------------

There are cases where a client holds several certificate and key pairs,
and may not want to load all of them in the credentials structure.  The
following example demonstrates the use of the certificate selection
callback.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>
#include <gnutls/abstract.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* A TLS client that loads the certificate and key.
 */

#define MAX_BUF 1024
#define MSG "GET / HTTP/1.0\r\n\r\n"

#define CERT_FILE "cert.pem"
#define KEY_FILE "key.pem"
#define CAFILE "ca.pem"

extern int tcp_connect (void);
extern void tcp_close (int sd);

static int
cert_callback (gnutls_session_t session,
               const gnutls_datum_t * req_ca_rdn, int nreqs,
               const gnutls_pk_algorithm_t * sign_algos,
               int sign_algos_length, gnutls_pcert_st ** pcert,
               unsigned int *pcert_length, gnutls_privkey_t * pkey);

gnutls_pcert_st crt;
gnutls_privkey_t key;

/* Helper functions to load a certificate and key
 * files into memory.
 */
static gnutls_datum_t
load_file (const char *file)
{
  FILE *f;
  gnutls_datum_t loaded_file = { NULL, 0 };
  long filelen;
  void *ptr;

  if (!(f = fopen (file, "r"))
      || fseek (f, 0, SEEK_END) != 0
      || (filelen = ftell (f)) < 0
      || fseek (f, 0, SEEK_SET) != 0
      || !(ptr = malloc ((size_t) filelen))
      || fread (ptr, 1, (size_t) filelen, f) < (size_t) filelen)
    {
      return loaded_file;
    }

  loaded_file.data = ptr;
  loaded_file.size = (unsigned int) filelen;
  return loaded_file;
}

static void
unload_file (gnutls_datum_t data)
{
  free (data.data);
}

/* Load the certificate and the private key.
 */
static void
load_keys (void)
{
  int ret;
  gnutls_datum_t data;
  gnutls_x509_privkey_t x509_key;

  data = load_file (CERT_FILE);
  if (data.data == NULL)
    {
      fprintf (stderr, "*** Error loading certificate file.\n");
      exit (1);
    }

  ret = gnutls_pcert_import_x509_raw (&crt, &data, GNUTLS_X509_FMT_PEM, 0);
  if (ret < 0)
    {
      fprintf (stderr, "*** Error loading certificate file: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  unload_file (data);

  data = load_file (KEY_FILE);
  if (data.data == NULL)
    {
      fprintf (stderr, "*** Error loading key file.\n");
      exit (1);
    }

  gnutls_x509_privkey_init (&x509_key);

  ret = gnutls_x509_privkey_import (x509_key, &data, GNUTLS_X509_FMT_PEM);
  if (ret < 0)
    {
      fprintf (stderr, "*** Error loading key file: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  gnutls_privkey_init (&key);

  ret =
    gnutls_privkey_import_x509 (key, x509_key,
                                GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE);
  if (ret < 0)
    {
      fprintf (stderr, "*** Error importing key: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  unload_file (data);
}

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  gnutls_priority_t priorities_cache;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;
  /* Allow connections to servers that have OpenPGP keys as well.
   */

  gnutls_global_init ();

  load_keys ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* priorities */
  gnutls_priority_init (&priorities_cache, "NORMAL", NULL);


  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_retrieve_function2 (xcred, cert_callback);

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set (session, priorities_cache);

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);
  gnutls_priority_deinit (priorities_cache);

  gnutls_global_deinit ();

  return 0;
}



/* This callback should be associated with a session by calling
 * gnutls_certificate_client_set_retrieve_function( session, cert_callback),
 * before a handshake.
 */

static int
cert_callback (gnutls_session_t session,
               const gnutls_datum_t * req_ca_rdn, int nreqs,
               const gnutls_pk_algorithm_t * sign_algos,
               int sign_algos_length, gnutls_pcert_st ** pcert,
               unsigned int *pcert_length, gnutls_privkey_t * pkey)
{
  char issuer_dn[256];
  int i, ret;
  size_t len;
  gnutls_certificate_type_t type;

  /* Print the server's trusted CAs
   */
  if (nreqs > 0)
    printf ("- Server's trusted authorities:\n");
  else
    printf ("- Server did not send us any trusted authorities names.\n");

  /* print the names (if any) */
  for (i = 0; i < nreqs; i++)
    {
      len = sizeof (issuer_dn);
      ret = gnutls_x509_rdn_get (&req_ca_rdn[i], issuer_dn, &len);
      if (ret >= 0)
        {
          printf ("   [%d]: ", i);
          printf ("%s\n", issuer_dn);
        }
    }

  /* Select a certificate and return it.
   * The certificate must be of any of the "sign algorithms"
   * supported by the server.
   */
  type = gnutls_certificate_type_get (session);
  if (type == GNUTLS_CRT_X509)
    {
      *pcert_length = 1;
      *pcert = &crt;
      *pkey = key;
    }
  else
    {
      return -1;
    }

  return 0;

}


File: gnutls.info,  Node: Verifying a certificate,  Next: Client using a PKCS 11 token with TLS,  Prev: Using a callback to select the certificate to use,  Up: Client examples

8.1.6 Verifying a certificate
-----------------------------

An example is listed below which uses the high level verification
functions to verify a given certificate list.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>

#include "examples.h"

/* All the available CRLs
 */
gnutls_x509_crl_t *crl_list;
int crl_list_size;

/* All the available trusted CAs
 */
gnutls_x509_crt_t *ca_list;
int ca_list_size;

static int print_details_func (gnutls_x509_crt_t cert,
                               gnutls_x509_crt_t issuer,
                               gnutls_x509_crl_t crl,
                               unsigned int verification_output);

/* This function will try to verify the peer's certificate chain, and
 * also check if the hostname matches.
 */
void
verify_certificate_chain (const char *hostname,
                          const gnutls_datum_t * cert_chain,
                          int cert_chain_length)
{
  int i;
  gnutls_x509_trust_list_t tlist;
  gnutls_x509_crt_t *cert;

  unsigned int output;

  /* Initialize the trusted certificate list. This should be done
   * once on initialization. gnutls_x509_crt_list_import2() and
   * gnutls_x509_crl_list_import2() can be used to load them.
   */
  gnutls_x509_trust_list_init (&tlist, 0);

  gnutls_x509_trust_list_add_cas (tlist, ca_list, ca_list_size, 0);
  gnutls_x509_trust_list_add_crls (tlist, crl_list, crl_list_size,
                                   GNUTLS_TL_VERIFY_CRL, 0);

  cert = malloc (sizeof (*cert) * cert_chain_length);

  /* Import all the certificates in the chain to
   * native certificate format.
   */
  for (i = 0; i < cert_chain_length; i++)
    {
      gnutls_x509_crt_init (&cert[i]);
      gnutls_x509_crt_import (cert[i], &cert_chain[i], GNUTLS_X509_FMT_DER);
    }

  gnutls_x509_trust_list_verify_named_crt (tlist, cert[0], hostname,
                                           strlen (hostname),
                                           GNUTLS_VERIFY_DISABLE_CRL_CHECKS,
                                           &output, print_details_func);

  /* if this certificate is not explicitly trusted verify against CAs
   */
  if (output != 0)
    {
      gnutls_x509_trust_list_verify_crt (tlist, cert, cert_chain_length, 0,
                                         &output, print_details_func);
    }

  if (output & GNUTLS_CERT_INVALID)
    {
      fprintf (stderr, "Not trusted");

      if (output & GNUTLS_CERT_SIGNER_NOT_FOUND)
        fprintf (stderr, ": no issuer was found");
      if (output & GNUTLS_CERT_SIGNER_NOT_CA)
        fprintf (stderr, ": issuer is not a CA");
      if (output & GNUTLS_CERT_NOT_ACTIVATED)
        fprintf (stderr, ": not yet activated\n");
      if (output & GNUTLS_CERT_EXPIRED)
        fprintf (stderr, ": expired\n");

      fprintf (stderr, "\n");
    }
  else
    fprintf (stderr, "Trusted\n");

  /* Check if the name in the first certificate matches our destination!
   */
  if (!gnutls_x509_crt_check_hostname (cert[0], hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
    }

  gnutls_x509_trust_list_deinit (tlist, 1);

  return;
}

static int
print_details_func (gnutls_x509_crt_t cert,
                    gnutls_x509_crt_t issuer, gnutls_x509_crl_t crl,
                    unsigned int verification_output)
{
  char name[512];
  char issuer_name[512];
  size_t name_size;
  size_t issuer_name_size;

  issuer_name_size = sizeof (issuer_name);
  gnutls_x509_crt_get_issuer_dn (cert, issuer_name, &issuer_name_size);

  name_size = sizeof (name);
  gnutls_x509_crt_get_dn (cert, name, &name_size);

  fprintf (stdout, "\tSubject: %s\n", name);
  fprintf (stdout, "\tIssuer: %s\n", issuer_name);

  if (issuer != NULL)
    {
      issuer_name_size = sizeof (issuer_name);
      gnutls_x509_crt_get_dn (issuer, issuer_name, &issuer_name_size);

      fprintf (stdout, "\tVerified against: %s\n", issuer_name);
    }

  if (crl != NULL)
    {
      issuer_name_size = sizeof (issuer_name);
      gnutls_x509_crl_get_issuer_dn (crl, issuer_name, &issuer_name_size);

      fprintf (stdout, "\tVerified against CRL of: %s\n", issuer_name);
    }

  fprintf (stdout, "\tVerification output: %x\n\n", verification_output);

  return 0;
}


File: gnutls.info,  Node: Client using a PKCS 11 token with TLS,  Next: Client with Resume capability example,  Prev: Verifying a certificate,  Up: Client examples

8.1.7 Using a PKCS #11 token with TLS
-------------------------------------

This example will demonstrate how to load keys and certificates from a
PKCS #11 token, and use it with a TLS connection.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>
#include <gnutls/pkcs11.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <getpass.h> /* for getpass() */

/* A TLS client that loads the certificate and key.
 */

#define MAX_BUF 1024
#define MSG "GET / HTTP/1.0\r\n\r\n"
#define MIN(x,y) (((x)<(y))?(x):(y))

#define CAFILE "ca.pem"

/* The URLs of the objects can be obtained
 * using p11tool --list-all --login
 */
#define KEY_URL "pkcs11:manufacturer=SomeManufacturer;object=Private%20Key" \
  ";objecttype=private;id=%db%5b%3e%b5%72%33"
#define CERT_URL "pkcs11:manufacturer=SomeManufacturer;object=Certificate;" \
  "objecttype=cert;id=db%5b%3e%b5%72%33"

extern int tcp_connect (void);
extern void tcp_close (int sd);

static int
pin_callback (void *user, int attempt, const char *token_url,
              const char *token_label, unsigned int flags, char *pin,
              size_t pin_max)
{
  const char *password;
  int len;

  printf ("PIN required for token '%s' with URL '%s'\n", token_label,
          token_url);
  if (flags & GNUTLS_PKCS11_PIN_FINAL_TRY)
    printf ("*** This is the final try before locking!\n");
  if (flags & GNUTLS_PKCS11_PIN_COUNT_LOW)
    printf ("*** Only few tries left before locking!\n");
  if (flags & GNUTLS_PKCS11_PIN_WRONG)
    printf ("*** Wrong PIN\n");

  password = getpass ("Enter pin: ");
  if (password == NULL || password[0] == 0)
    {
      fprintf (stderr, "No password given\n");
      exit (1);
    }

  len = MIN (pin_max, strlen (password));
  memcpy (pin, password, len);
  pin[len] = 0;

  return 0;
}

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  gnutls_priority_t priorities_cache;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;
  /* Allow connections to servers that have OpenPGP keys as well.
   */

  gnutls_global_init ();
  /* PKCS11 private key operations might require PIN.
   * Register a callback.
   */
  gnutls_pkcs11_set_pin_function (pin_callback, NULL);

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* priorities */
  gnutls_priority_init (&priorities_cache, "NORMAL", NULL);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_key_file (xcred, CERT_URL, KEY_URL, GNUTLS_X509_FMT_DER);

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set (session, priorities_cache);

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);
  gnutls_priority_deinit (priorities_cache);

  gnutls_global_deinit ();

  return 0;
}


File: gnutls.info,  Node: Client with Resume capability example,  Next: Simple client example with SRP authentication,  Prev: Client using a PKCS 11 token with TLS,  Up: Client examples

8.1.8 Client with resume capability example
-------------------------------------------

This is a modification of the simple client example. Here we
demonstrate the use of session resumption. The client tries to connect
once using TLS, close the connection and then try to establish a new
connection using the previously negotiated data.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>

/* Those functions are defined in other examples.
 */
extern void check_alert (gnutls_session_t session, int ret);
extern int tcp_connect (void);
extern void tcp_close (int sd);

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

int
main (void)
{
  int ret;
  int sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;

  /* variables used in session resuming
   */
  int t;
  char *session_data = NULL;
  size_t session_data_size = 0;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  for (t = 0; t < 2; t++)
    {                           /* connect 2 times to the server */

      sd = tcp_connect ();

      gnutls_init (&session, GNUTLS_CLIENT);

      gnutls_priority_set_direct (session, "PERFORMANCE:!ARCFOUR-128", NULL);

      gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

      if (t > 0)
        {
          /* if this is not the first time we connect */
          gnutls_session_set_data (session, session_data, session_data_size);
          free (session_data);
        }

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

      /* Perform the TLS handshake
       */
      ret = gnutls_handshake (session);

      if (ret < 0)
        {
          fprintf (stderr, "*** Handshake failed\n");
          gnutls_perror (ret);
          goto end;
        }
      else
        {
          printf ("- Handshake was completed\n");
        }

      if (t == 0)
        {                       /* the first time we connect */
          /* get the session data size */
          gnutls_session_get_data (session, NULL, &session_data_size);
          session_data = malloc (session_data_size);

          /* put session data to the session variable */
          gnutls_session_get_data (session, session_data, &session_data_size);

        }
      else
        {                       /* the second time we connect */

          /* check if we actually resumed the previous session */
          if (gnutls_session_is_resumed (session) != 0)
            {
              printf ("- Previous session was resumed\n");
            }
          else
            {
              fprintf (stderr, "*** Previous session was NOT resumed\n");
            }
        }

      /* This function was defined in a previous example
       */
      /* print_info(session); */

      gnutls_record_send (session, MSG, strlen (MSG));

      ret = gnutls_record_recv (session, buffer, MAX_BUF);
      if (ret == 0)
        {
          printf ("- Peer has closed the TLS connection\n");
          goto end;
        }
      else if (ret < 0)
        {
          fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
          goto end;
        }

      printf ("- Received %d bytes: ", ret);
      for (ii = 0; ii < ret; ii++)
        {
          fputc (buffer[ii], stdout);
        }
      fputs ("\n", stdout);

      gnutls_bye (session, GNUTLS_SHUT_RDWR);

    end:

      tcp_close (sd);

      gnutls_deinit (session);

    }                           /* for() */

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}


File: gnutls.info,  Node: Simple client example with SRP authentication,  Next: Simple client example in C++,  Prev: Client with Resume capability example,  Up: Client examples

8.1.9 Simple client example with SRP authentication
---------------------------------------------------

The following client is a very simple SRP TLS client which connects to
a server and authenticates using a _username_ and a _password_. The
server may authenticate itself using a certificate, and in that case it
has to be verified.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <gnutls/gnutls.h>

/* Those functions are defined in other examples.
 */
extern void check_alert (gnutls_session_t session, int ret);
extern int tcp_connect (void);
extern void tcp_close (int sd);

#define MAX_BUF 1024
#define USERNAME "user"
#define PASSWORD "pass"
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

int
main (void)
{
  int ret;
  int sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  gnutls_srp_client_credentials_t srp_cred;
  gnutls_certificate_credentials_t cert_cred;

  gnutls_global_init ();

  gnutls_srp_allocate_client_credentials (&srp_cred);
  gnutls_certificate_allocate_credentials (&cert_cred);

  gnutls_certificate_set_x509_trust_file (cert_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);
  gnutls_srp_set_client_credentials (srp_cred, USERNAME, PASSWORD);

  /* connects to server
   */
  sd = tcp_connect ();

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_CLIENT);


  /* Set the priorities.
   */
  gnutls_priority_set_direct (session, "NORMAL:+SRP:+SRP-RSA:+SRP-DSS", NULL);

  /* put the SRP credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_SRP, srp_cred);
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, cert_cred);

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (gnutls_error_is_fatal (ret) == 1 || ret == 0)
    {
      if (ret == 0)
        {
          printf ("- Peer has closed the GnuTLS connection\n");
          goto end;
        }
      else
        {
          fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
          goto end;
        }
    }
  else
    check_alert (session, ret);

  if (ret > 0)
    {
      printf ("- Received %d bytes: ", ret);
      for (ii = 0; ii < ret; ii++)
        {
          fputc (buffer[ii], stdout);
        }
      fputs ("\n", stdout);
    }
  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_srp_free_client_credentials (srp_cred);
  gnutls_certificate_free_credentials (cert_cred);

  gnutls_global_deinit ();

  return 0;
}


File: gnutls.info,  Node: Simple client example in C++,  Next: Helper function for TCP connections,  Prev: Simple client example with SRP authentication,  Up: Client examples

8.1.10 Simple client example using the C++ API
----------------------------------------------

The following client is a simple example of a client client utilizing
the GnuTLS C++ API.

#include <config.h>
#include <iostream>
#include <stdexcept>
#include <gnutls/gnutls.h>
#include <gnutls/gnutlsxx.h>
#include <cstring> /* for strlen */

/* A very basic TLS client, with anonymous authentication.
 * written by Eduardo Villanueva Che.
 */

#define MAX_BUF 1024
#define SA struct sockaddr

#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern "C"
{
    int tcp_connect(void);
    void tcp_close(int sd);
}


int main(void)
{
    int sd = -1;
    gnutls_global_init();

    try
    {

        /* Allow connections to servers that have OpenPGP keys as well.
         */
        gnutls::client_session session;

        /* X509 stuff */
        gnutls::certificate_credentials credentials;


        /* sets the trusted cas file
         */
        credentials.set_x509_trust_file(CAFILE, GNUTLS_X509_FMT_PEM);
        /* put the x509 credentials to the current session
         */
        session.set_credentials(credentials);

        /* Use default priorities */
        session.set_priority ("NORMAL", NULL);

        /* connect to the peer
         */
        sd = tcp_connect();
        session.set_transport_ptr((gnutls_transport_ptr_t) sd);

        /* Perform the TLS handshake
         */
        int ret = session.handshake();
        if (ret < 0)
        {
            throw std::runtime_error("Handshake failed");
        }
        else
        {
            std::cout << "- Handshake was completed" << std::endl;
        }

        session.send(MSG, strlen(MSG));
        char buffer[MAX_BUF + 1];
        ret = session.recv(buffer, MAX_BUF);
        if (ret == 0)
        {
            throw std::runtime_error("Peer has closed the TLS connection");
        }
        else if (ret < 0)
        {
            throw std::runtime_error(gnutls_strerror(ret));
        }

        std::cout << "- Received " << ret << " bytes:" << std::endl;
        std::cout.write(buffer, ret);
        std::cout << std::endl;

        session.bye(GNUTLS_SHUT_RDWR);
    }
    catch (std::exception &ex)
    {
        std::cerr << "Exception caught: " << ex.what() << std::endl;
    }

    if (sd != -1)
        tcp_close(sd);

    gnutls_global_deinit();

    return 0;
}


File: gnutls.info,  Node: Helper function for TCP connections,  Prev: Simple client example in C++,  Up: Client examples

8.1.11 Helper function for TCP connections
------------------------------------------

This helper function abstracts away TCP connection handling from the
other examples.  It is required to build some examples.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>

#define SA struct sockaddr

/* tcp.c */
int tcp_connect (void);
void tcp_close (int sd);

/* Connects to the peer and returns a socket
 * descriptor.
 */
extern int
tcp_connect (void)
{
  const char *PORT = "5556";
  const char *SERVER = "127.0.0.1";
  int err, sd;
  struct sockaddr_in sa;

  /* connects to server
   */
  sd = socket (AF_INET, SOCK_STREAM, 0);

  memset (&sa, '\0', sizeof (sa));
  sa.sin_family = AF_INET;
  sa.sin_port = htons (atoi (PORT));
  inet_pton (AF_INET, SERVER, &sa.sin_addr);

  err = connect (sd, (SA *) & sa, sizeof (sa));
  if (err < 0)
    {
      fprintf (stderr, "Connect error\n");
      exit (1);
    }

  return sd;
}

/* closes the given socket descriptor.
 */
extern void
tcp_close (int sd)
{
  shutdown (sd, SHUT_RDWR);     /* no more receptions */
  close (sd);
}


File: gnutls.info,  Node: Server examples,  Next: Miscellaneous examples,  Prev: Client examples,  Up: GnuTLS application examples

8.2 Server examples
===================

This section contains examples of TLS and SSL servers, using GnuTLS.

* Menu:

* Echo Server with X.509 authentication::
* Echo Server with OpenPGP authentication::
* Echo Server with SRP authentication::
* Echo Server with anonymous authentication::


File: gnutls.info,  Node: Echo Server with X.509 authentication,  Next: Echo Server with OpenPGP authentication,  Up: Server examples

8.2.1 Echo server with X.509 authentication
-------------------------------------------

This example is a very simple echo server which supports X.509
authentication, using the RSA ciphersuites.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#define KEYFILE "serverkey.pem"
#define CERTFILE "servercert.pem"
#define CAFILE "cacert.pem"
#define CRLFILE "crl.pem"
/* This is a sample TLS 1.0 echo server, using X.509 authentication.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */
#define DH_BITS 1024

/* These are global */
gnutls_certificate_credentials_t x509_cred;
gnutls_priority_t priority_cache;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

gnutls_init (&session, GNUTLS_CLIENT);
int data_length=0;//hard-coding this length assuming 4 proxies already exist in the connection.
void *data=malloc(80);
/*printf("Existing Proxy_Info retrived by proxy from outgoing TLS connection\n");
for(int i=0;i<data_length;i+=4){
int random_num=rand()%20;
printf("%u ",random_num);
if((i-1)%5==0&&i!=0)
printf("\n");
memcpy(data+i,&random_num,sizeof(int));
}
*/
gnutls_proxyinfo_set (session, GNUTLS_NAME_DNS, "karthikmihir",strlen("karthikmihir"),data,data_length,0);
gnutls_priority_set (session, priority_cache);

  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, x509_cred);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_REQUEST);

  /* Set maximum compatibility mode. This is only suggested on public webservers
   * that need to trade security for compatibility
   */
  gnutls_session_enable_compatibility_mode (session);

  return session;
}

static gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. When short bit length is used, it might
   * be wise to regenerate parameters.
   *
   * Check the ex-serv-export.c example for using static
   * parameters.
   */
  gnutls_dh_params_init (&dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_certificate_allocate_credentials (&x509_cred);
  gnutls_certificate_set_x509_trust_file (x509_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_crl_file (x509_cred, CRLFILE,
                                        GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_key_file (x509_cred, CERTFILE, KEYFILE,
                                        GNUTLS_X509_FMT_PEM);

  generate_dh_params ();

  gnutls_priority_init (&priority_cache, "NORMAL", NULL);


  gnutls_certificate_set_dh_params (x509_cred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) & sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("Server ready. Listening to port '%d'.\n\n", PORT);


  client_len = sizeof (sa_cli);


  for (;;)
    {
      session = initialize_tls_session ();
      sd = accept (listen_sd, (SA *) & sa_cli, &client_len);
      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);

      if (ret < 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }



      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret < 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_certificate_free_credentials (x509_cred);
  gnutls_priority_deinit (priority_cache);

  gnutls_global_deinit ();

  return 0;

}


File: gnutls.info,  Node: Echo Server with OpenPGP authentication,  Next: Echo Server with SRP authentication,  Prev: Echo Server with X.509 authentication,  Up: Server examples

8.2.2 Echo server with OpenPGP authentication
---------------------------------------------

The following example is an echo server which supports OpenPGP key
authentication. You can easily combine this functionality --that is
have a server that supports both X.509 and OpenPGP certificates-- but
we separated them to keep these examples as simple as possible.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#include <gnutls/openpgp.h>

#define KEYFILE "secret.asc"
#define CERTFILE "public.asc"
#define RINGFILE "ring.gpg"

/* This is a sample TLS 1.0-OpenPGP echo server.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */
#define DH_BITS 1024

/* These are global */
gnutls_certificate_credentials_t cred;
gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. These should be discarded and regenerated
   * once a day, once a week or once a month. Depending on the
   * security requirements.
   */
  gnutls_dh_params_init (&dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&session, GNUTLS_SERVER);

  gnutls_priority_set_direct (session, "NORMAL:+CTYPE-OPENPGP", NULL);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_REQUEST);

  gnutls_dh_set_prime_bits (session, DH_BITS);

  return session;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;
  char name[256];

  strcpy (name, "Echo Server");

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_certificate_allocate_credentials (&cred);
  gnutls_certificate_set_openpgp_keyring_file (cred, RINGFILE,
                                               GNUTLS_OPENPGP_FMT_BASE64);

  gnutls_certificate_set_openpgp_key_file (cred, CERTFILE, KEYFILE,
                                           GNUTLS_OPENPGP_FMT_BASE64);

  generate_dh_params ();

  gnutls_certificate_set_dh_params (cred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) & sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("%s ready. Listening to port '%d'.\n\n", name, PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) & sa_cli, &client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret < 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret < 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_certificate_free_credentials (cred);

  gnutls_global_deinit ();

  return 0;

}


File: gnutls.info,  Node: Echo Server with SRP authentication,  Next: Echo Server with anonymous authentication,  Prev: Echo Server with OpenPGP authentication,  Up: Server examples

8.2.3 Echo server with SRP authentication
-----------------------------------------

This is a server which supports SRP authentication. It is also possible
to combine this functionality with a certificate server. Here it is
separate for simplicity.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <gnutls/gnutls.h>

#define SRP_PASSWD "tpasswd"
#define SRP_PASSWD_CONF "tpasswd.conf"

#define KEYFILE "key.pem"
#define CERTFILE "cert.pem"
#define CAFILE "ca.pem"

/* This is a sample TLS-SRP echo server.
 */

#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

/* These are global */
gnutls_srp_server_credentials_t srp_cred;
gnutls_certificate_credentials_t cert_cred;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&session, GNUTLS_SERVER);

  gnutls_priority_set_direct (session, "NORMAL:-KX-ALL:+SRP:+SRP-DSS:+SRP-RSA", NULL);

  gnutls_credentials_set (session, GNUTLS_CRD_SRP, srp_cred);
  /* for the certificate authenticated ciphersuites.
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, cert_cred);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_IGNORE);

  return session;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;
  char name[256];

  strcpy (name, "Echo Server");

  gnutls_global_init ();

  /* SRP_PASSWD a password file (created with the included srptool utility)
   */
  gnutls_srp_allocate_server_credentials (&srp_cred);
  gnutls_srp_set_server_credentials_file (srp_cred, SRP_PASSWD,
                                          SRP_PASSWD_CONF);

  gnutls_certificate_allocate_credentials (&cert_cred);
  gnutls_certificate_set_x509_trust_file (cert_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_x509_key_file (cert_cred, CERTFILE, KEYFILE,
                                        GNUTLS_X509_FMT_PEM);

  /* TCP socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) & sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("%s ready. Listening to port '%d'.\n\n", name, PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) & sa_cli, &client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret < 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");
      printf ("- User %s was connected\n", gnutls_srp_server_get_username(session));

      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret < 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection. */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_srp_free_server_credentials (srp_cred);
  gnutls_certificate_free_credentials (cert_cred);

  gnutls_global_deinit ();

  return 0;

}


File: gnutls.info,  Node: Echo Server with anonymous authentication,  Prev: Echo Server with SRP authentication,  Up: Server examples

8.2.4 Echo Server with anonymous authentication
-----------------------------------------------

This example server support anonymous authentication, and could be used
to serve the example client for anonymous authentication.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif


#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <gnutls/gnutls.h>
#include "get_ip.c"
#define KEYFILE "serverkey.pem"
#define CERTFILE "servercert.pem"
#define CAFILE "cacert.pem"
#define CRLFILE "crl.pem"

/* This is a sample TLS 1.0 echo server, using X.509 authentication.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5557               /* listen to 5556 port */
#define DH_BITS 1024
#define MSG "PROJECT DEADLINE : MAR 23 :P"

static int _verify_certificate_callback (gnutls_session_t session);

/* These are global */

gnutls_certificate_credentials_t x509_cred;
gnutls_priority_t priority_cache;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

gnutls_init (&session, GNUTLS_CLIENT);
///int data_length=0;//hard-coding this length assuming 4 proxies already exist in the connection.
//void *data=malloc(80);
/*printf("Existing Proxy_Info retrived by proxy from outgoing TLS connection\n");
for(int i=0;i<data_length;i+=4){
int random_num=rand()%20;
printf("%u ",random_num);
if((i-1)%5==0&&i!=0)
printf("\n");
memcpy(data+i,&random_num,sizeof(int));
}
*/
//gnutls_proxyinfo_set (session, GNUTLS_NAME_DNS, "karthikmihir",strlen("karthikmihir"),data,data_length,0);
gnutls_priority_set (session, priority_cache);

  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, x509_cred);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_REQUEST);

  /* Set maximum compatibility mode. This is only suggested on public webservers
   * that need to trade security for compatibility
   */
  gnutls_session_enable_compatibility_mode (session);

  return session;
}

static gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. When short bit length is used, it might
   * be wise to regenerate parameters.
   *
   * Check the ex-serv-export.c example for using static
   * parameters.
   */
  gnutls_dh_params_init (&dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}


// ------------------------- PROXY CODE BEGINS -----------------------------------
int tcp_connect1 (void)
{
  const char *PORT1 = "5556";
  const char *SERVER1 = "127.0.0.1";
  int err, sd;
  struct sockaddr_in sa;

  /* connects to server
   */
  sd = socket (AF_INET, SOCK_STREAM, 0);

  memset (&sa, '1', sizeof (sa));
  sa.sin_family = AF_INET;
  sa.sin_port = htons (atoi (PORT1));
  inet_pton (AF_INET, SERVER1, &sa.sin_addr);

  err = connect (sd, (SA *) & sa, sizeof (sa));
  if (err < 0)
    {
      fprintf (stderr, "Connect error\n");
      exit (1);
    }

  return sd;
}

/* closes the given socket descriptor.
 */
void tcp_close1 (int sd)
{
  shutdown (sd, SHUT_RDWR);     /* no more receptions */
  close (sd);
}
void print_proxy_info(void* data,int data_length){
printf("\nGot Proxy_Info, Total data packet length:%d\n",data_length);
for (int i=0;i<data_length;i+=4){
if(i%20==0)
	printf("Proxy - %d:\nEncryption ALgorithm : %u\n",(i/12)+1,*(int*)(data+i));
if(i%20==4)
	printf("Key Exchange ALgorithm : %u\n",*(int*)(data+i));
if(i%20==8)
	printf("MAC ALgorithm : %u\n",*(int*)(data+i));
if(i%20==12){
char *p1=malloc(100);
int ip=*(int*)(data+i);
get_ip_str(ip,p1);
printf("IP Address : %s\n",p1);
}
if(i%20==16){
printf("MAC Address : %u\n\n",*(int*)(data+i));
}
}
}


int proxy_client(void* data,size_t *data_length,unsigned int *type){
  int ret, sd, ii;
  gnutls_session_t session;
  //int data_length=0;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;
  gnutls_global_set_log_level(3);
  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&xcred);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, _verify_certificate_callback);

  /* If client holds a certificate it can be set using the following:
   */
     gnutls_certificate_set_x509_key_file (xcred,
                                           "clientcert.pem", "clientkey.pem",
                                           GNUTLS_X509_FMT_PEM);

  /* Initialize TLS session
   */
  gnutls_init (&session, GNUTLS_SERVER);

  gnutls_session_set_ptr (session, (void *) "karthik");


  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &err);
  if (ret < 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);
  printf("Certificate credentials set\n");

  /* connect to the peer
   */
  sd = tcp_connect1 ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */

  ret = gnutls_handshake (session);

/* Get ProxyInfo Extension Data
*/
gnutls_proxyinfo_get (session,data,data_length,type,0);
print_proxy_info(data,*data_length);

  if (ret < 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {

      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret < 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii < ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close1 (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;

}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;

  /* Data buffer for extension
   */
  void *data=malloc(200);
  size_t data_length=200;
  unsigned int type;

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_certificate_allocate_credentials (&x509_cred);
  gnutls_certificate_set_x509_trust_file (x509_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_crl_file (x509_cred, CRLFILE,
                                        GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_key_file (x509_cred, CERTFILE, KEYFILE,
                                        GNUTLS_X509_FMT_PEM);

  generate_dh_params ();

  gnutls_priority_init (&priority_cache, "NORMAL", NULL);


  gnutls_certificate_set_dh_params (x509_cred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) & sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("Server ready. Listening to port '%d'.\n\n", PORT);


  client_len = sizeof (sa_cli);


  for (;;)
    {
      sd = accept (listen_sd, (SA *) & sa_cli, &client_len);
      int test = proxy_client(data,&data_length,&type);

      printf("Return code from Proxy Client: %d\n", test);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));
      session = initialize_tls_session ();
      gnutls_proxyinfo_set (session, GNUTLS_NAME_DNS, "karthikmihir",strlen("karthikmihir"),data,data_length,0);

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);

      if (ret < 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }



      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret < 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_certificate_free_credentials (x509_cred);
  gnutls_priority_deinit (priority_cache);

  gnutls_global_deinit ();

  return 0;

}



/* This function will verify the peer's certificate, and check
 * if the hostname matches, as well as the activation, expiration dates.
 */
static int
_verify_certificate_callback (gnutls_session_t session)
{
  unsigned int status;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size;
  int ret;
  gnutls_x509_crt_t cert;
  const char *hostname;

  /* read hostname */
  hostname = gnutls_session_get_ptr (session);

  /* This verification function uses the trusted CAs in the credentials
   * structure. So you must have installed one or more CA certificates.
   */
  ret = gnutls_certificate_verify_peers2 (session, &status);
  if (ret < 0)
    {
      printf ("Error\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  if (status & GNUTLS_CERT_INVALID)
    printf ("The certificate is not trusted.\n");

  if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)
    printf ("The certificate hasn't got a known issuer.\n");

  if (status & GNUTLS_CERT_REVOKED)
    printf ("The certificate has been revoked.\n");

  if (status & GNUTLS_CERT_EXPIRED)
    printf ("The certificate has expired\n");

  if (status & GNUTLS_CERT_NOT_ACTIVATED)
    printf ("The certificate is not yet activated\n");

  /* Up to here the process is the same for X.509 certificates and
   * OpenPGP keys. From now on X.509 certificates are assumed. This can
   * be easily extended to work with openpgp keys as well.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return GNUTLS_E_CERTIFICATE_ERROR;

  if (gnutls_x509_crt_init (&cert) < 0)
    {
      printf ("error in initialization\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);
  if (cert_list == NULL)
    {
      printf ("No certificate was found!\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  /* This is not a real world example, since we only check the first
   * certificate in the given chain.
   */
  if (gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER) < 0)
    {
      printf ("error parsing certificate\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }


  if (!gnutls_x509_crt_check_hostname (cert, hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  gnutls_x509_crt_deinit (cert);

  /* notify gnutls to continue handshake normally */
  return 0;
}


File: gnutls.info,  Node: Miscellaneous examples,  Prev: Server examples,  Up: GnuTLS application examples

8.3 Miscellaneous examples
==========================

* Menu:

* Checking for an alert::
* X.509 certificate parsing example::


File: gnutls.info,  Node: Checking for an alert,  Next: X.509 certificate parsing example,  Up: Miscellaneous examples

8.3.1 Checking for an alert
---------------------------

This is a function that checks if an alert has been received in the
current session.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>

#include "examples.h"

/* This function will check whether the given return code from
 * a gnutls function (recv/send), is an alert, and will print
 * that alert.
 */
void
check_alert (gnutls_session_t session, int ret)
{
  int last_alert;

  if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED
      || ret == GNUTLS_E_FATAL_ALERT_RECEIVED)
    {
      last_alert = gnutls_alert_get (session);

      /* The check for renegotiation is only useful if we are
       * a server, and we had requested a rehandshake.
       */
      if (last_alert == GNUTLS_A_NO_RENEGOTIATION &&
          ret == GNUTLS_E_WARNING_ALERT_RECEIVED)
        printf ("* Received NO_RENEGOTIATION alert. "
                "Client Does not support renegotiation.\n");
      else
        printf ("* Received alert '%d': %s.\n", last_alert,
                gnutls_alert_get_name (last_alert));
    }
}


File: gnutls.info,  Node: X.509 certificate parsing example,  Prev: Checking for an alert,  Up: Miscellaneous examples

8.3.2 X.509 certificate parsing example
---------------------------------------

To demonstrate the X.509 parsing capabilities an example program is
listed below.  That program reads the peer's certificate, and prints
information about it.

/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <gnutls/gnutls.h>
#include <gnutls/x509.h>

#include "examples.h"

static const char *
bin2hex (const void *bin, size_t bin_size)
{
  static char printable[110];
  const unsigned char *_bin = bin;
  char *print;
  size_t i;

  if (bin_size > 50)
    bin_size = 50;

  print = printable;
  for (i = 0; i < bin_size; i++)
    {
      sprintf (print, "%.2x ", _bin[i]);
      print += 2;
    }

  return printable;
}

/* This function will print information about this session's peer
 * certificate.
 */
void
print_x509_certificate_info (gnutls_session_t session)
{
  char serial[40];
  char dn[256];
  size_t size;
  unsigned int algo, bits;
  time_t expiration_time, activation_time;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size = 0;
  gnutls_x509_crt_t cert;
  gnutls_datum_t cinfo;

  /* This function only works for X.509 certificates.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return;

  cert_list = gnutls_certificate_get_peers (session, &cert_list_size);

  printf ("Peer provided %d certificates.\n", cert_list_size);

  if (cert_list_size > 0)
    {
      int ret;

      /* we only print information about the first certificate.
       */
      gnutls_x509_crt_init (&cert);

      gnutls_x509_crt_import (cert, &cert_list[0], GNUTLS_X509_FMT_DER);

      printf ("Certificate info:\n");

      /* This is the preferred way of printing short information about
         a certificate. */

      ret = gnutls_x509_crt_print (cert, GNUTLS_CRT_PRINT_ONELINE, &cinfo);
      if (ret == 0)
        {
          printf ("\t%s\n", cinfo.data);
          gnutls_free (cinfo.data);
        }

      /* If you want to extract fields manually for some other reason,
         below are popular example calls. */

      expiration_time = gnutls_x509_crt_get_expiration_time (cert);
      activation_time = gnutls_x509_crt_get_activation_time (cert);

      printf ("\tCertificate is valid since: %s", ctime (&activation_time));
      printf ("\tCertificate expires: %s", ctime (&expiration_time));

      /* Print the serial number of the certificate.
       */
      size = sizeof (serial);
      gnutls_x509_crt_get_serial (cert, serial, &size);

      printf ("\tCertificate serial number: %s\n", bin2hex (serial, size));

      /* Extract some of the public key algorithm's parameters
       */
      algo = gnutls_x509_crt_get_pk_algorithm (cert, &bits);

      printf ("Certificate public key: %s",
              gnutls_pk_algorithm_get_name (algo));

      /* Print the version of the X.509
       * certificate.
       */
      printf ("\tCertificate version: #%d\n",
              gnutls_x509_crt_get_version (cert));

      size = sizeof (dn);
      gnutls_x509_crt_get_dn (cert, dn, &size);
      printf ("\tDN: %s\n", dn);

      size = sizeof (dn);
      gnutls_x509_crt_get_issuer_dn (cert, dn, &size);
      printf ("\tIssuer's DN: %s\n", dn);

      gnutls_x509_crt_deinit (cert);

    }
}


File: gnutls.info,  Node: Other included programs,  Next: Internal architecture of GnuTLS,  Prev: GnuTLS application examples,  Up: Top

9 Other included programs
*************************

Included with GnuTLS are also a few command line tools that let you use
the library for common tasks without writing an application.  The
applications are discussed in this chapter.

* Menu:

* The gnutls-cli tool::
* The gnutls-serv tool::
* The gnutls-cli-debug tool::


File: gnutls.info,  Node: The gnutls-cli tool,  Next: The gnutls-serv tool,  Up: Other included programs

9.1 The gnutls-cli tool
=======================

Simple client program to set up a TLS connection to some other
computer.  It sets up a TLS connection and forwards data from the
standard input to the secured socket and vice versa.

     GnuTLS test client
     Usage:  gnutls-cli [options] hostname

          -d, --debug integer      Enable debugging
          -r, --resume             Connect, establish a session. Connect
                                   again and resume this session.
          -s, --starttls           Connect, establish a plain session and
                                   start TLS when EOF or a SIGALRM is
                                   received.
          --crlf                   Send CR LF instead of LF.
          --x509fmtder             Use DER format for certificates to read
                                   from.
          -f, --fingerprint        Send the openpgp fingerprint, instead
                                   of the key.
          --disable-extensions     Disable all the TLS extensions.
          --print-cert             Print the certificate in PEM format.
          --recordsize integer     The maximum record size to advertize.
          -V, --verbose            More verbose output.
          --ciphers cipher1 cipher2...
                                   Ciphers to enable.
          --protocols protocol1 protocol2...
                                   Protocols to enable.
          --comp comp1 comp2...    Compression methods to enable.
          --macs mac1 mac2...      MACs to enable.
          --kx kx1 kx2...          Key exchange methods to enable.
          --ctypes certType1 certType2...
                                   Certificate types to enable.
          --priority PRIORITY STRING
                                   Priorities string.
          --x509cafile FILE        Certificate file to use.
          --x509crlfile FILE       CRL file to use.
          --pgpkeyfile FILE        PGP Key file to use.
          --pgpkeyring FILE        PGP Key ring file to use.
          --pgpcertfile FILE       PGP Public Key (certificate) file to
                                   use.
          --pgpsubkey HEX|auto     PGP subkey to use.
          --x509keyfile FILE       X.509 key file to use.
          --x509certfile FILE      X.509 Certificate file to use.
          --srpusername NAME       SRP username to use.
          --srppasswd PASSWD       SRP password to use.
          --pskusername NAME       PSK username to use.
          --pskkey KEY             PSK key (in hex) to use.
          --opaque-prf-input DATA
                                   Use Opaque PRF Input DATA.
          -p, --port PORT          The port to connect to.
          --insecure               Don't abort program if server
                                   certificate can't be validated.
          -l, --list               Print a list of the supported
                                   algorithms and modes.
          -h, --help               prints this help
          -v, --version            prints the program's version number

* Menu:

* Example client PSK connection::


File: gnutls.info,  Node: Example client PSK connection,  Up: The gnutls-cli tool

9.1.1 Example client PSK connection
-----------------------------------

To connect to a server using PSK authentication, you need to enable the
choice of PSK by using a cipher priority parameter such as in the
example below.

     $ ./gnutls-cli -p 5556 localhost --pskusername psk_identity \
       --pskkey 88f3824b3e5659f52d00e959bacab954b6540344 \
       --priority NORMAL:-KX-ALL:+ECDHE-PSK:+DHE-PSK:+PSK
     Resolving 'localhost'...
     Connecting to '127.0.0.1:5556'...
     - PSK authentication.
     - Version: TLS1.1
     - Key Exchange: PSK
     - Cipher: AES-128-CBC
     - MAC: SHA1
     - Compression: NULL
     - Handshake was completed

     - Simple Client Mode:

By keeping the `--pskusername' parameter and removing the `--pskkey'
parameter, it will query only for the password during the handshake.


File: gnutls.info,  Node: The gnutls-serv tool,  Next: The gnutls-cli-debug tool,  Prev: The gnutls-cli tool,  Up: Other included programs

9.2 The gnutls-serv tool
========================

Simple server program that listens to incoming TLS connections.

     GnuTLS test server
     Usage: gnutls-serv [options]

          -d, --debug integer      Enable debugging
          -g, --generate           Generate Diffie-Hellman Parameters.
          -p, --port integer       The port to connect to.
          -q, --quiet              Suppress some messages.
          --nodb                   Does not use the resume database.
          --http                   Act as an HTTP Server.
          --echo                   Act as an Echo Server.
          --dhparams FILE          DH params file to use.
          --x509fmtder             Use DER format for certificates
          --x509cafile FILE        Certificate file to use.
          --x509crlfile FILE       CRL file to use.
          --pgpkeyring FILE        PGP Key ring file to use.
          --pgpkeyfile FILE        PGP Key file to use.
          --pgpcertfile FILE       PGP Public Key (certificate) file to
                                   use.
          --pgpsubkey HEX|auto     PGP subkey to use.
          --x509keyfile FILE       X.509 key file to use.
          --x509certfile FILE      X.509 Certificate file to use.
          --x509dsakeyfile FILE    Alternative X.509 key file to use.
          --x509dsacertfile FILE   Alternative X.509 certificate file to
                                   use.
          -r, --require-cert       Require a valid certificate.
          -a, --disable-client-cert
                                   Disable request for a client
                                   certificate.
          --pskpasswd FILE         PSK password file to use.
          --pskhint HINT           PSK identity hint to use.
          --srppasswd FILE         SRP password file to use.
          --srppasswdconf FILE     SRP password conf file to use.
          --opaque-prf-input DATA
                                   Use Opaque PRF Input DATA.
          --ciphers cipher1 cipher2...
                                   Ciphers to enable.
          --protocols protocol1 protocol2...
                                   Protocols to enable.
          --comp comp1 comp2...    Compression methods to enable.
          --macs mac1 mac2...      MACs to enable.
          --kx kx1 kx2...          Key exchange methods to enable.
          --ctypes certType1 certType2...
                                   Certificate types to enable.
          --priority PRIORITY STRING
                                   Priorities string.
          -l, --list               Print a list of the supported
                                   algorithms  and modes.
          -h, --help               prints this help
          -v, --version            prints the program's version number

* Menu:

* Setting up a test HTTPS server::


File: gnutls.info,  Node: Setting up a test HTTPS server,  Up: The gnutls-serv tool

9.2.1 Setting up a test HTTPS server
------------------------------------

Running your own TLS server based on GnuTLS can be useful when
debugging clients and/or GnuTLS itself.  This section describes how to
use `gnutls-serv' as a simple HTTPS server.

The most basic server can be started as:

     gnutls-serv --http

It will only support anonymous ciphersuites, which many TLS clients
refuse to use.

The next step is to add support for X.509.  First we generate a CA:

     $ certtool --generate-privkey > x509-ca-key.pem
     $ echo 'cn = GnuTLS test CA' > ca.tmpl
     $ echo 'ca' >> ca.tmpl
     $ echo 'cert_signing_key' >> ca.tmpl
     $ certtool --generate-self-signed --load-privkey x509-ca-key.pem \
       --template ca.tmpl --outfile x509-ca.pem
     ...

Then generate a server certificate.  Remember to change the dns_name
value to the name of your server host, or skip that command to avoid
the field.

     $ certtool --generate-privkey > x509-server-key.pem
     $ echo 'organization = GnuTLS test server' > server.tmpl
     $ echo 'cn = test.gnutls.org' >> server.tmpl
     $ echo 'tls_www_server' >> server.tmpl
     $ echo 'encryption_key' >> server.tmpl
     $ echo 'signing_key' >> server.tmpl
     $ echo 'dns_name = test.gnutls.org' >> server.tmpl
     $ certtool --generate-certificate --load-privkey x509-server-key.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template server.tmpl --outfile x509-server.pem
     ...

For use in the client, you may want to generate a client certificate as
well.

     $ certtool --generate-privkey > x509-client-key.pem
     $ echo 'cn = GnuTLS test client' > client.tmpl
     $ echo 'tls_www_client' >> client.tmpl
     $ echo 'encryption_key' >> client.tmpl
     $ echo 'signing_key' >> client.tmpl
     $ certtool --generate-certificate --load-privkey x509-client-key.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template client.tmpl --outfile x509-client.pem
     ...

To be able to import the client key/certificate into some applications,
you will need to convert them into a PKCS#12 structure.  This also
encrypts the security sensitive key with a password.

     $ certtool --to-p12 --load-ca-certificate x509-ca.pem \
       --load-privkey x509-client-key.pem --load-certificate x509-client.pem \
       --outder --outfile x509-client.p12

For icing, we'll create a proxy certificate for the client too.

     $ certtool --generate-privkey > x509-proxy-key.pem
     $ echo 'cn = GnuTLS test client proxy' > proxy.tmpl
     $ certtool --generate-proxy --load-privkey x509-proxy-key.pem \
       --load-ca-certificate x509-client.pem --load-ca-privkey x509-client-key.pem \
       --load-certificate x509-client.pem --template proxy.tmpl \
       --outfile x509-proxy.pem
     ...

Then start the server again:

     $ gnutls-serv --http \
                 --x509cafile x509-ca.pem \
                 --x509keyfile x509-server-key.pem \
                 --x509certfile x509-server.pem

Try connecting to the server using your web browser.  Note that the
server listens to port 5556 by default.

While you are at it, to allow connections using DSA, you can also
create a DSA key and certificate for the server.  These credentials
will be used in the final example below.

     $ certtool --generate-privkey --dsa > x509-server-key-dsa.pem
     $ certtool --generate-certificate --load-privkey x509-server-key-dsa.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template server.tmpl --outfile x509-server-dsa.pem
     ...

The next step is to create OpenPGP credentials for the server.

     gpg --gen-key
     ...enter whatever details you want, use 'test.gnutls.org' as name...

Make a note of the OpenPGP key identifier of the newly generated key,
here it was `5D1D14D8'.  You will need to export the key for GnuTLS to
be able to use it.

     gpg -a --export 5D1D14D8 > openpgp-server.txt
     gpg --export 5D1D14D8 > openpgp-server.bin
     gpg --export-secret-keys 5D1D14D8 > openpgp-server-key.bin
     gpg -a --export-secret-keys 5D1D14D8 > openpgp-server-key.txt

Let's start the server with support for OpenPGP credentials:

     gnutls-serv --http \
                 --pgpkeyfile openpgp-server-key.txt \
                 --pgpcertfile openpgp-server.txt

The next step is to add support for SRP authentication. This requires
an SRP password file (see *note Invoking srptool::).  To start the
server with SRP support:

     gnutls-serv --http \
                 --srppasswdconf srp-tpasswd.conf \
                 --srppasswd srp-passwd.txt

Let's also start a server with support for PSK. This would require a
password file created with `psktool' (see *note Invoking psktool::).

     gnutls-serv --http \
                 --pskpasswd psk-passwd.txt

Finally, we start the server with all the earlier parameters and you
get this command:

     gnutls-serv --http \
                 --x509cafile x509-ca.pem \
                 --x509keyfile x509-server-key.pem \
                 --x509certfile x509-server.pem \
                 --x509dsakeyfile x509-server-key-dsa.pem \
                 --x509dsacertfile x509-server-dsa.pem \
                 --pgpkeyfile openpgp-server-key.txt \
                 --pgpcertfile openpgp-server.txt \
                 --srppasswdconf srp-tpasswd.conf \
                 --srppasswd srp-passwd.txt \
                 --pskpasswd psk-passwd.txt


File: gnutls.info,  Node: The gnutls-cli-debug tool,  Prev: The gnutls-serv tool,  Up: Other included programs

9.3 The gnutls-cli-debug tool
=============================

This program was created to assist in debugging GnuTLS, but it might be
useful to extract a TLS server's capabilities.  It's purpose is to
connect onto a TLS server, perform some tests and print the server's
capabilities. If called with the `-v' parameter more checks will be
performed. An example output is:

     crystal:/cvs/gnutls/src$ ./gnutls-cli-debug localhost -p 5556
     Resolving 'localhost'...
     Connecting to '127.0.0.1:5556'...
     Checking for TLS 1.1 support... yes
     Checking fallback from TLS 1.1 to... N/A
     Checking for TLS 1.0 support... yes
     Checking for SSL 3.0 support... yes
     Checking for version rollback bug in RSA PMS... no
     Checking for version rollback bug in Client Hello... no
     Checking whether we need to disable TLS 1.0... N/A
     Checking whether the server ignores the RSA PMS version... no
     Checking whether the server can accept Hello Extensions... yes
     Checking whether the server can accept cipher suites not in SSL 3.0 spec... yes
     Checking for certificate information... N/A
     Checking for trusted CAs... N/A
     Checking whether the server understands TLS closure alerts... yes
     Checking whether the server supports session resumption... yes
     Checking for export-grade ciphersuite support... no
     Checking RSA-export ciphersuite info... N/A
     Checking for anonymous authentication support... no
     Checking anonymous Diffie-Hellman group info... N/A
     Checking for ephemeral Diffie-Hellman support... no
     Checking ephemeral Diffie-Hellman group info... N/A
     Checking for AES cipher support (TLS extension)... yes
     Checking for 3DES cipher support... yes
     Checking for ARCFOUR 128 cipher support... yes
     Checking for ARCFOUR 40 cipher support... no
     Checking for MD5 MAC support... yes
     Checking for SHA1 MAC support... yes
     Checking for ZLIB compression support (TLS extension)... yes
     Checking for max record size (TLS extension)... yes
     Checking for SRP authentication support (TLS extension)... yes
     Checking for OpenPGP authentication support (TLS extension)... no


File: gnutls.info,  Node: Internal architecture of GnuTLS,  Next: Support,  Prev: Other included programs,  Up: Top

10 Internal Architecture of GnuTLS
**********************************

This chapter is to give a brief description of the way GnuTLS works.
The focus is to give an idea to potential developers and those who want
to know what happens inside the black box.

* Menu:

* The TLS Protocol::
* TLS Handshake Protocol::
* TLS Authentication Methods::
* TLS Extension Handling::
* Cryptographic Backend::


File: gnutls.info,  Node: The TLS Protocol,  Next: TLS Handshake Protocol,  Up: Internal architecture of GnuTLS

10.1 The TLS Protocol
=====================

The main use case for the TLS protocol is shown in *note
fig:client-server::.  A user of a library implementing the protocol
expects no less than this functionality, i.e., to be able to set
parameters such as the accepted security level, perform a negotiation
with the peer and be able to exchange data.

 [image src="gnutls-client-server-use-case.png" ]

Figure 10.1: TLS protocol use case.


File: gnutls.info,  Node: TLS Handshake Protocol,  Next: TLS Authentication Methods,  Prev: The TLS Protocol,  Up: Internal architecture of GnuTLS

10.2 TLS Handshake Protocol
===========================

The GnuTLS handshake protocol is implemented as a state machine that
waits for input or returns immediately when the non-blocking transport
layer functions are used. The main idea is shown in *note
fig:gnutls-handshake::.

 [image src="gnutls-handshake-state.png" ]

Figure 10.2: GnuTLS handshake state machine.

Also the way the input is processed varies per ciphersuite. Several
implementations of the internal handlers are available and *note
gnutls_handshake:: only multiplexes the input to the appropriate
handler. For example a PSK ciphersuite has a different implementation
of the `process_client_key_exchange' than a certificate ciphersuite. We
illustrate the idea in *note fig:gnutls-handshake-sequence::.

 [image src="gnutls-handshake-sequence.png" ]

Figure 10.3: GnuTLS handshake process sequence.


File: gnutls.info,  Node: TLS Authentication Methods,  Next: TLS Extension Handling,  Prev: TLS Handshake Protocol,  Up: Internal architecture of GnuTLS

10.3 TLS Authentication Methods
===============================

In GnuTLS authentication methods can be implemented quite easily.
Since the required changes to add a new authentication method affect
only the handshake protocol, a simple interface is used. An
authentication method needs to implement the functions shown below.

typedef struct
{
  const char *name;
  int (*gnutls_generate_server_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_server_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_cert_vrfy) (gnutls_session_t, gnutls_buffer_st *);
  int (*gnutls_generate_server_certificate_request) (gnutls_session_t,
                                                     gnutls_buffer_st *);

  int (*gnutls_process_server_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_client_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_server_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_cert_vrfy) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_server_certificate_request) (gnutls_session_t,
                                                    opaque *, size_t);
} mod_auth_st;

Those functions are responsible for the interpretation of the handshake
protocol messages. It is common for such functions to read data from
one or more `credentials_t' structures(1) and write data, such as
certificates, usernames etc. to `auth_info_t' structures.

Simple examples of existing authentication methods can be seen in
`auth/psk.c' for PSK ciphersuites and `auth/srp.c' for SRP
ciphersuites. After implementing these functions the structure holding
its pointers has to be registered in `gnutls_algorithms.c' in the
`_gnutls_kx_algorithms' structure.

---------- Footnotes ----------

(1) such as the `gnutls_certificate_credentials_t' structures


File: gnutls.info,  Node: TLS Extension Handling,  Next: Cryptographic Backend,  Prev: TLS Authentication Methods,  Up: Internal architecture of GnuTLS

10.4 TLS Extension Handling
===========================

As with authentication methods, the TLS extensions handlers can be
implemented using the interface shown below.

typedef int (*gnutls_ext_recv_func) (gnutls_session_t session,
                                     const unsigned char *data, size_t len);
typedef int (*gnutls_ext_send_func) (gnutls_session_t session,
                                     gnutls_buffer_st *extdata);

Here there are two functions, one for receiving the extension data and
one for sending. These functions have to check internally whether they
operate in client or server side.

A simple example of an extension handler can be seen in `ext/srp.c' in
GnuTLS' source code. After implementing these functions, together with
the extension number they handle, they have to be registered using
`_gnutls_ext_register' in `gnutls_extensions.c' typically within
`_gnutls_ext_init'.

* Menu:

* Adding a new TLS extension::


File: gnutls.info,  Node: Adding a new TLS extension,  Up: TLS Extension Handling

10.4.1 Adding a new TLS extension
---------------------------------

Adding support for a new TLS extension is done from time to time, and
the process to do so is not difficult.  Here are the steps you need to
follow if you wish to do this yourself.  For sake of discussion, let's
consider adding support for the hypothetical TLS extension `foobar'.

Add `configure' option like `--enable-foobar' or `--disable-foobar'.
....................................................................

This step is useful when the extension code is large and it might be
desirable to disable the extension under some circumstances. Otherwise
it can be safely skipped.

Whether to chose enable or disable depends on whether you intend to
make the extension be enabled by default.  Look at existing checks
(i.e., SRP, authz) for how to model the code.  For example:

     AC_MSG_CHECKING([whether to disable foobar support])
     AC_ARG_ENABLE(foobar,
     	AS_HELP_STRING([--disable-foobar],
     		[disable foobar support]),
     	ac_enable_foobar=no)
     if test x$ac_enable_foobar != xno; then
      AC_MSG_RESULT(no)
      AC_DEFINE(ENABLE_FOOBAR, 1, [enable foobar])
     else
      ac_full=0
      AC_MSG_RESULT(yes)
     fi
     AM_CONDITIONAL(ENABLE_FOOBAR, test "$ac_enable_foobar" != "no")

These lines should go in `lib/m4/hooks.m4'.

Add IANA extension value to `extensions_t' in `gnutls_int.h'.
.............................................................

A good name for the value would be GNUTLS_EXTENSION_FOOBAR.  Check with
`http://www.iana.org/assignments/tls-extensiontype-values' for
allocated values.  For experiments, you could pick a number but
remember that some consider it a bad idea to deploy such modified
version since it will lead to interoperability problems in the future
when the IANA allocates that number to someone else, or when the foobar
protocol is allocated another number.

Add an entry to `_gnutls_extensions' in `gnutls_extensions.c'.
..............................................................

A typical entry would be:

       int ret;

     #if ENABLE_FOOBAR
       ret = _gnutls_ext_register (&foobar_ext);
       if (ret != GNUTLS_E_SUCCESS)
         return ret;
     #endif

Most likely you'll need to add an `#include "ext/foobar.h"', that will
contain something like like:
       extension_entry_st foobar_ext = {
         .name = "FOOBAR",
         .type = GNUTLS_EXTENSION_FOOBAR,
         .parse_type = GNUTLS_EXT_TLS,
         .recv_func = _foobar_recv_params,
         .send_func = _foobar_send_params,
         .pack_func = _foobar_pack,
         .unpack_func = _foobar_unpack,
         .deinit_func = NULL
       }

The GNUTLS_EXTENSION_FOOBAR is the integer value you added to
`gnutls_int.h' earlier.  In this structure you specify the functions to
read the extension from the hello message, the function to send the
reply to, and two more functions to pack and unpack from stored session
data (e.g. when resumming a session). The `deinit' function will be
called to deinitialize the extension's private parameters, if any.

Note that the conditional `ENABLE_FOOBAR' definition should only be
used if step 1 with the `configure' options has taken place.

Add new files  that implement the extension.
............................................

The functions you are responsible to add are those mentioned in the
previous step.  They should be added in a file such as `ext/foobar.c'
and headers should be placed in `ext/foobar.h'.  As a starter, you
could add this:

     int
     _foobar_recv_params (gnutls_session_t session, const opaque * data,
                          size_t data_size)
     {
       return 0;
     }

     int
     _foobar_send_params (gnutls_session_t session, gnutls_buffer_st* data)
     {
       return 0;
     }

     int
     _foobar_pack (extension_priv_data_t epriv, gnutls_buffer_st * ps)
     {
        /* Append the extension's internal state to buffer */
        return 0;
     }

     int
     _foobar_unpack (gnutls_buffer_st * ps, extension_priv_data_t * epriv)
     {
        /* Read the internal state from buffer */
        return 0;
     }

The `_foobar_recv_params' function is responsible for parsing incoming
extension data (both in the client and server).

The `_foobar_send_params' function is responsible for sending extension
data (both in the client and server).

If you receive length fields that doesn't match, return
`GNUTLS_E_UNEXPECTED_PACKET_LENGTH'.  If you receive invalid data,
return `GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER'.  You can use other error
codes from the list in *note Error codes::.  Return 0 on success.

An extension typically stores private information in the `session' data
for later usage. That can be done using the functions
`_gnutls_ext_set_session_data' and `_gnutls_ext_get_session_data'. You
can check simple examples at `ext/max_record.c' and `ext/server_name.c'
extensions.  That private information can be saved and restored across
session resumption if the following functions are set:

The `_foobar_pack' function is responsible for packing internal
extension data to save them in the session resumption storage.

The `_foobar_unpack' function is responsible for restoring session data
from the session resumption storage.

Recall that both the client and server, send and receive parameters,
and your code most likely will need to do different things depending on
which mode it is in.  It may be useful to make this distinction
explicit in the code.  Thus, for example, a better template than above
would be:

     int
     _gnutls_foobar_recv_params (gnutls_session_t session,
                                 const opaque * data,
                                 size_t data_size)
     {
       if (session->security_parameters.entity == GNUTLS_CLIENT)
         return foobar_recv_client (session, data, data_size);
       else
         return foobar_recv_server (session, data, data_size);
     }

     int
     _gnutls_foobar_send_params (gnutls_session_t session,
                                 gnutls_buffer_st * data)
     {
       if (session->security_parameters.entity == GNUTLS_CLIENT)
         return foobar_send_client (session, data);
       else
         return foobar_send_server (session, data);
     }

The functions used would be declared as `static' functions, of the
appropriate prototype, in the same file.  When adding the files, you'll
need to add them to `ext/Makefile.am' as well, for example:

     if ENABLE_FOOBAR
     libgnutls_ext_la_SOURCES += ext/foobar.c ext/foobar.h
     endif

Add API functions to enable/disable the extension.
..................................................

It might be desirable to allow users of the extension to request use of
the extension, or set extension specific data.  This can be implemented
by adding extension specific function calls that can be added to
`includes/gnutls/gnutls.h', as long as the LGPLv3+ applies.  The
implementation of the function should lie in the `ext/foobar.c' file.

To make the API available in the shared library you need to add the
symbol in `lib/libgnutls.map', so that the symbol is exported properly.

When writing GTK-DOC style documentation for your new APIs, don't
forget to add `Since:' tags to indicate the GnuTLS version the API was
introduced in.


File: gnutls.info,  Node: Cryptographic Backend,  Prev: TLS Extension Handling,  Up: Internal architecture of GnuTLS

10.5 Cryptographic Backend
==========================

Today most new processors, either for embedded or desktop systems
include either instructions  intended to speed up cryptographic
operations, or a co-processor with cryptographic capabilities. Taking
advantage of those is a challenging task for every cryptographic
application or library. Unfortunately the cryptographic library that
GnuTLS is based on takes no advantage of these capabilities. For this
reason GnuTLS handles this internally by following a layered approach
to accessing cryptographic operations as in *note fig:crypto-layers::.

 [image src="gnutls-crypto-layers.png" ]

Figure 10.4: GnuTLS cryptographic back-end design.

The TLS layer uses a cryptographic provider layer, that will in turn
either use the default crypto provider - a software crypto library, or
use an external crypto provider, if available.

10.5.1 Cryptographic library layer
----------------------------------

The Cryptographic library layer, currently supports only libnettle.
Other cryptographic libraries might be supported in the future.

10.5.2 External cryptography provider
-------------------------------------

Systems that include a cryptographic co-processor, typically come with
kernel drivers to utilize the operations from software. For this reason
GnuTLS provides a layer where each individual algorithm used can be
replaced by another implementation, i.e., the one provided by the
driver. The FreeBSD, OpenBSD and Linux kernels(1) include already a
number of hardware assisted implementations, and also provide an
interface to access them, called `/dev/crypto'.  GnuTLS will take
advantage of this interface if compiled with special options. That is
because in most systems where hardware-assisted cryptographic
operations are not available, using this interface might actually harm
performance.

In systems that include cryptographic instructions with the CPU's
instructions set, using the kernel interface will introduce an unneeded
layer. For this reason GnuTLS includes such optimizations found in
popular processors such as the AES-NI or VIA PADLOCK instruction sets.
This is achieved using a mechanism that detects CPU capabilities and
overrides parts of crypto backend at runtime.  The next section
discusses the registration of a detected algorithm optimization. For
more information please consult the GnuTLS source code in
`lib/accelerated/'.

Overriding specific algorithms
..............................

When an optimized implementation of a single algorithm is available,
say a hardware assisted version of AES-CBC then the following
(internal) functions, from `crypto-backend.h', can be used to register
those algorithms.

   * `gnutls_crypto_single_cipher_register': To register a cipher
     algorithm.

   * `gnutls_crypto_single_digest_register': To register a hash
     (digest) or MAC algorithm.


Those registration functions will only replace the specified algorithm
and leave the rest of subsystem intact.

Overriding the cryptographic library
....................................

In some systems, that might contain a broad acceleration engine, it
might be desirable to override big parts of the cryptographic backend,
or even all of them. T following functions are provided for this reason.

   * `gnutls_crypto_cipher_register': To override the cryptographic
     algorithms backend.

   * `gnutls_crypto_digest_register': To override the digest algorithms
     backend.

   * `gnutls_crypto_rnd_register': To override the random number
     generator backend.

   * `gnutls_crypto_bigint_register': To override the big number number
     operations backend.

   * `gnutls_crypto_pk_register': To override the public key encryption
     backend. This is tied to the big number operations so either none
     or both of them should be overriden.


---------- Footnotes ----------

(1) Check `http://home.gna.org/cryptodev-linux/' for the Linux kernel
implementation of `/dev/crypto'.


File: gnutls.info,  Node: Support,  Next: Error codes,  Prev: Internal architecture of GnuTLS,  Up: Top

Appendix A Support
******************

* Menu:

* Getting help::
* Commercial Support::
* Bug Reports::
* Contributing::


File: gnutls.info,  Node: Getting help,  Next: Commercial Support,  Up: Support

A.1 Getting Help
================

A mailing list where users may help each other exists, and you can
reach it by sending e-mail to <help-gnutls@gnu.org>.  Archives of the
mailing list discussions, and an interface to manage subscriptions, is
available through the World Wide Web at
`http://lists.gnu.org/mailman/listinfo/help-gnutls'.

A mailing list for developers are also available, see
`http://www.gnu.org/software/gnutls/lists.html'.  Bug reports should be
sent to <bug-gnutls@gnu.org>, see *note Bug Reports::.


File: gnutls.info,  Node: Commercial Support,  Next: Bug Reports,  Prev: Getting help,  Up: Support

A.2 Commercial Support
======================

Commercial support is available for users of GnuTLS.  The kind of
support that can be purchased may include:

   * Implement new features.  Such as a new TLS extension.

   * Port GnuTLS to new platforms.  This could include porting to an
     embedded platforms that may need memory or size optimization.

   * Integrating TLS as a security environment in your existing project.

   * System design of components related to TLS.


If you are interested, please write to:

Simon Josefsson Datakonsult
Hagagatan 24
113 47 Stockholm
Sweden

E-mail: simon@josefsson.org

If your company provides support related to GnuTLS and would like to be
mentioned here, contact the authors.


File: gnutls.info,  Node: Bug Reports,  Next: Contributing,  Prev: Commercial Support,  Up: Support

A.3 Bug Reports
===============

If you think you have found a bug in GnuTLS, please investigate it and
report it.

   * Please make sure that the bug is really in GnuTLS, and preferably
     also check that it hasn't already been fixed in the latest version.

   * You have to send us a test case that makes it possible for us to
     reproduce the bug.

   * You also have to explain what is wrong; if you get a crash, or if
     the results printed are not good and in that case, in what way.
     Make sure that the bug report includes all information you would
     need to fix this kind of bug for someone else.


Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won't
do anything about it (apart from asking you to send better bug reports).

If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.

Send your bug report to:

                         `bug-gnutls@gnu.org'


File: gnutls.info,  Node: Contributing,  Prev: Bug Reports,  Up: Support

A.4 Contributing
================

If you want to submit a patch for inclusion - from solving a typo you
discovered, up to adding support for a new feature - you should submit
it as a bug report, using the process in *note Bug Reports::.  There
are some things that you can do to increase the chances for it to be
included in the official package.

Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation.
This is to protect the freedom of the project.  If you have not already
signed papers, we will send you the necessary information when you
submit your contribution.

For contributions that doesn't consist of actual programming code, the
only guidelines are common sense.  For code contributions, a number of
style guides will help you:

   * Coding Style.  Follow the GNU Standards document.

     If you normally code using another coding standard, there is no
     problem, but you should use `indent' to reformat the code before
     submitting your work.

   * Use the unified diff format `diff -u'.

   * Return errors.  No reason whatsoever should abort the execution of
     the library.  Even memory allocation errors, e.g. when malloc
     return NULL, should work although result in an error code.

   * Design with thread safety in mind.  Don't use global variables.
     Don't even write to per-handle global variables unless the
     documented behaviour of the function you write is to write to the
     per-handle global variable.

   * Avoid using the C math library.  It causes problems for embedded
     implementations, and in most situations it is very easy to avoid
     using it.

   * Document your functions.  Use comments before each function
     headers, that, if properly formatted, are extracted into Texinfo
     manuals and GTK-DOC web pages.

   * Supply a ChangeLog and NEWS entries, where appropriate.



File: gnutls.info,  Node: Error codes,  Next: API reference,  Prev: Support,  Up: Top

Appendix B Error Codes and Descriptions
***************************************

The error codes used throughout the library are described below.  The
return code `GNUTLS_E_SUCCESS' indicate successful operation, and is
guaranteed to have the value 0, so you can use it in logical
expressions.

`GNUTLS_E_AGAIN:'
     Resource temporarily unavailable, try again.

`GNUTLS_E_ASN1_DER_ERROR:'
     ASN1 parser: Error in DER parsing.

`GNUTLS_E_ASN1_DER_OVERFLOW:'
     ASN1 parser: Overflow in DER parsing.

`GNUTLS_E_ASN1_ELEMENT_NOT_FOUND:'
     ASN1 parser: Element was not found.

`GNUTLS_E_ASN1_GENERIC_ERROR:'
     ASN1 parser: Generic parsing error.

`GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND:'
     ASN1 parser: Identifier was not found

`GNUTLS_E_ASN1_SYNTAX_ERROR:'
     ASN1 parser: Syntax error.

`GNUTLS_E_ASN1_TAG_ERROR:'
     ASN1 parser: Error in TAG.

`GNUTLS_E_ASN1_TAG_IMPLICIT:'
     ASN1 parser: error in implicit tag

`GNUTLS_E_ASN1_TYPE_ANY_ERROR:'
     ASN1 parser: Error in type 'ANY'.

`GNUTLS_E_ASN1_VALUE_NOT_FOUND:'
     ASN1 parser: Value was not found.

`GNUTLS_E_ASN1_VALUE_NOT_VALID:'
     ASN1 parser: Value is not valid.

`GNUTLS_E_BAD_COOKIE:'
     The cookie was bad.

`GNUTLS_E_BASE64_DECODING_ERROR:'
     Base64 decoding error.

`GNUTLS_E_BASE64_ENCODING_ERROR:'
     Base64 encoding error.

`GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR:'
     Base64 unexpected header error.

`GNUTLS_E_CERTIFICATE_ERROR:'
     Error in the certificate.

`GNUTLS_E_CERTIFICATE_KEY_MISMATCH:'
     The certificate and the given key do not match.

`GNUTLS_E_CERTIFICATE_LIST_UNSORTED:'
     The provided X.509 certificate list is not sorted (in subject to
     issuer order)

`GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE:'
     Channel binding data not available

`GNUTLS_E_COMPRESSION_FAILED:'
     Compression of the TLS record packet has failed.

`GNUTLS_E_CONSTRAINT_ERROR:'
     Some constraint limits were reached.

`GNUTLS_E_CRYPTODEV_DEVICE_ERROR:'
     Error opening /dev/crypto

`GNUTLS_E_CRYPTODEV_IOCTL_ERROR:'
     Error interfacing with /dev/crypto

`GNUTLS_E_CRYPTO_ALREADY_REGISTERED:'
     There is already a crypto algorithm with lower priority.

`GNUTLS_E_CRYPTO_INIT_FAILED:'
     The initialization of crypto backend has failed.

`GNUTLS_E_DB_ERROR:'
     Error in Database backend.

`GNUTLS_E_DECOMPRESSION_FAILED:'
     Decompression of the TLS record packet has failed.

`GNUTLS_E_DECRYPTION_FAILED:'
     Decryption has failed.

`GNUTLS_E_DH_PRIME_UNACCEPTABLE:'
     The Diffie-Hellman prime sent by the server is not acceptable (not
     long enough).

`GNUTLS_E_ECC_NO_SUPPORTED_CURVES:'
     No supported ECC curves were found

`GNUTLS_E_ECC_UNSUPPORTED_CURVE:'
     The curve is unsupported

`GNUTLS_E_ENCRYPTION_FAILED:'
     Encryption has failed.

`GNUTLS_E_ERROR_IN_FINISHED_PACKET:'
     An error was encountered at the TLS Finished packet calculation.

`GNUTLS_E_EXPIRED:'
     The requested session has expired.

`GNUTLS_E_FATAL_ALERT_RECEIVED:'
     A TLS fatal alert has been received.

`GNUTLS_E_FILE_ERROR:'
     Error while reading file.

`GNUTLS_E_GOT_APPLICATION_DATA:'
     TLS Application data were received, while expecting handshake data.

`GNUTLS_E_HANDSHAKE_TOO_LARGE:'
     The handshake data size is too large.

`GNUTLS_E_HASH_FAILED:'
     Hashing has failed.

`GNUTLS_E_IA_VERIFY_FAILED:'
     Verifying TLS/IA phase checksum failed

`GNUTLS_E_ILLEGAL_PARAMETER:'
     An illegal parameter was found.

`GNUTLS_E_ILLEGAL_SRP_USERNAME:'
     The SRP username supplied is illegal.

`GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY:'
     The crypto library version is too old.

`GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY:'
     The tasn1 library version is too old.

`GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL:'
     The given DSA key is incompatible with the selected TLS protocol.

`GNUTLS_E_INSUFFICIENT_CREDENTIALS:'
     Insufficient credentials for that request.

`GNUTLS_E_INTERNAL_ERROR:'
     GnuTLS internal error.

`GNUTLS_E_INTERRUPTED:'
     Function was interrupted.

`GNUTLS_E_INVALID_PASSWORD:'
     The given password contains invalid characters.

`GNUTLS_E_INVALID_REQUEST:'
     The request is invalid.

`GNUTLS_E_INVALID_SESSION:'
     The specified session has been invalidated for some reason.

`GNUTLS_E_KEY_USAGE_VIOLATION:'
     Key usage violation in certificate has been detected.

`GNUTLS_E_LARGE_PACKET:'
     A large TLS record packet was received.

`GNUTLS_E_LOCKING_ERROR:'
     Thread locking error

`GNUTLS_E_MAC_VERIFY_FAILED:'
     The Message Authentication Code verification failed.

`GNUTLS_E_MEMORY_ERROR:'
     Internal error in memory allocation.

`GNUTLS_E_MPI_PRINT_FAILED:'
     Could not export a large integer.

`GNUTLS_E_MPI_SCAN_FAILED:'
     The scanning of a large integer has failed.

`GNUTLS_E_NO_CERTIFICATE_FOUND:'
     The peer did not send any certificate.

`GNUTLS_E_NO_CIPHER_SUITES:'
     No supported cipher suites have been found.

`GNUTLS_E_NO_COMPRESSION_ALGORITHMS:'
     No supported compression algorithms have been found.

`GNUTLS_E_NO_TEMPORARY_DH_PARAMS:'
     No temporary DH parameters were found.

`GNUTLS_E_NO_TEMPORARY_RSA_PARAMS:'
     No temporary RSA parameters were found.

`GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED:'
     The OpenPGP fingerprint is not supported.

`GNUTLS_E_OPENPGP_GETKEY_FAILED:'
     Could not get OpenPGP key.

`GNUTLS_E_OPENPGP_KEYRING_ERROR:'
     Error loading the keyring.

`GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR:'
     The OpenPGP key has not a preferred key set.

`GNUTLS_E_OPENPGP_SUBKEY_ERROR:'
     Could not find OpenPGP subkey.

`GNUTLS_E_OPENPGP_UID_REVOKED:'
     The OpenPGP User ID is revoked.

`GNUTLS_E_PARSING_ERROR:'
     Error in parsing.

`GNUTLS_E_PKCS11_ATTRIBUTE_ERROR:'
     PKCS #11 error in attribute

`GNUTLS_E_PKCS11_DATA_ERROR:'
     PKCS #11 error in data

`GNUTLS_E_PKCS11_DEVICE_ERROR:'
     PKCS #11 error in device

`GNUTLS_E_PKCS11_ERROR:'
     PKCS #11 error.

`GNUTLS_E_PKCS11_KEY_ERROR:'
     PKCS #11 error in key

`GNUTLS_E_PKCS11_LOAD_ERROR:'
     PKCS #11 initialization error.

`GNUTLS_E_PKCS11_PIN_ERROR:'
     PKCS #11 error in PIN.

`GNUTLS_E_PKCS11_PIN_EXPIRED:'
     PKCS #11 PIN expired

`GNUTLS_E_PKCS11_PIN_LOCKED:'
     PKCS #11 PIN locked

`GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE:'
     The requested PKCS #11 object is not available

`GNUTLS_E_PKCS11_SESSION_ERROR:'
     PKCS #11 error in session

`GNUTLS_E_PKCS11_SIGNATURE_ERROR:'
     PKCS #11 error in signature

`GNUTLS_E_PKCS11_SLOT_ERROR:'
     PKCS #11 error in slot

`GNUTLS_E_PKCS11_TOKEN_ERROR:'
     PKCS #11 error in token

`GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR:'
     PKCS #11 unsupported feature

`GNUTLS_E_PKCS11_USER_ERROR:'
     PKCS #11 user error

`GNUTLS_E_PKCS1_WRONG_PAD:'
     Wrong padding in PKCS1 packet.

`GNUTLS_E_PK_DECRYPTION_FAILED:'
     Public key decryption has failed.

`GNUTLS_E_PK_ENCRYPTION_FAILED:'
     Public key encryption has failed.

`GNUTLS_E_PK_SIGN_FAILED:'
     Public key signing has failed.

`GNUTLS_E_PK_SIG_VERIFY_FAILED:'
     Public key signature verification has failed.

`GNUTLS_E_PREMATURE_TERMINATION:'
     The TLS connection was non-properly terminated.

`GNUTLS_E_PULL_ERROR:'
     Error in the pull function.

`GNUTLS_E_PUSH_ERROR:'
     Error in the push function.

`GNUTLS_E_RANDOM_FAILED:'
     Failed to acquire random data.

`GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION:'
     An illegal TLS extension was received.

`GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER:'
     An illegal parameter has been received.

`GNUTLS_E_RECORD_LIMIT_REACHED:'
     The upper limit of record packet sequence numbers has been
     reached. Wow!

`GNUTLS_E_REHANDSHAKE:'
     Rehandshake was requested by the peer.

`GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE:'
     The requested data were not available.

`GNUTLS_E_SAFE_RENEGOTIATION_FAILED:'
     Safe renegotiation failed.

`GNUTLS_E_SHORT_MEMORY_BUFFER:'
     The given memory buffer is too short to hold parameters.

`GNUTLS_E_SRP_PWD_ERROR:'
     Error in password file.

`GNUTLS_E_SRP_PWD_PARSING_ERROR:'
     Parsing error in password file.

`GNUTLS_E_SUCCESS:'
     Success.

`GNUTLS_E_TIMEDOUT:'
     The operation timed out

`GNUTLS_E_TOO_MANY_EMPTY_PACKETS:'
     Too many empty record packets have been received.

`GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS:'
     Too many handshake packets have been received.

`GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET:'
     An unexpected TLS handshake packet was received.

`GNUTLS_E_UNEXPECTED_PACKET:'
     An unexpected TLS packet was received.

`GNUTLS_E_UNEXPECTED_PACKET_LENGTH:'
     A TLS packet with unexpected length was received.

`GNUTLS_E_UNKNOWN_ALGORITHM:'
     The specified algorithm or protocol is unknown.

`GNUTLS_E_UNKNOWN_CIPHER_SUITE:'
     Could not negotiate a supported cipher suite.

`GNUTLS_E_UNKNOWN_CIPHER_TYPE:'
     The cipher type is unsupported.

`GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM:'
     Could not negotiate a supported compression method.

`GNUTLS_E_UNKNOWN_HASH_ALGORITHM:'
     The hash algorithm is unknown.

`GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE:'
     The PKCS structure's bag type is unknown.

`GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE:'
     The PKCS structure's content type is unknown.

`GNUTLS_E_UNKNOWN_PK_ALGORITHM:'
     An unknown public key algorithm was encountered.

`GNUTLS_E_UNKNOWN_SRP_USERNAME:'
     The SRP username supplied is unknown.

`GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED:'
     Unsafe renegotiation denied.

`GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE:'
     The certificate type is not supported.

`GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM:'
     The signature algorithm is not supported.

`GNUTLS_E_UNSUPPORTED_VERSION_PACKET:'
     A record packet with illegal version was received.

`GNUTLS_E_UNWANTED_ALGORITHM:'
     An algorithm that is not enabled was negotiated.

`GNUTLS_E_USER_ERROR:'
     The operation was cancelled due to user error

`GNUTLS_E_WARNING_ALERT_RECEIVED:'
     A TLS warning alert has been received.

`GNUTLS_E_WARNING_IA_FPHF_RECEIVED:'
     Received a TLS/IA Final Phase Finished message

`GNUTLS_E_WARNING_IA_IPHF_RECEIVED:'
     Received a TLS/IA Intermediate Phase Finished message

`GNUTLS_E_X509_UNKNOWN_SAN:'
     Unknown Subject Alternative name in X.509 certificate.

`GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE:'
     The certificate has unsupported attributes.

`GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION:'
     Unsupported critical extension in X.509 certificate.

`GNUTLS_E_X509_UNSUPPORTED_OID:'
     The OID is not supported.



File: gnutls.info,  Node: API reference,  Next: Supported ciphersuites in GnuTLS,  Prev: Error codes,  Up: Top

Appendix C API reference
************************

* Menu:

* Core TLS API::
* Datagram TLS API::
* X509 certificate API::
* OpenPGP API::
* PKCS 12 API::
* PKCS 11 API::
* Abstract key API::
* Cryptographic API::
* Compatibility API::

